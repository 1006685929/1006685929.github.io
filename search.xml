<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018%2F10%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 序号 模式&amp;描述 包括 1 创建型模式(5) 工厂模式抽象工厂模式单例模式建造者模式原型模式 2 结构型模式(8) 适配器模式桥接模式过滤器模式组合模式装饰器模式外观模式享元模式代理模式 3 行为型模式(12) 责任链模式命令模式解释器模式迭代器模式中介者模式备忘录模式观察者模式状态模式空对象模式策略模式模板模式访问者模式 1.单例模式这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象 确保全局至多只有一个对象，减少了内存开销 用于：构造缓慢的对象，需要统一管理的资源 缺点：很多全局状态，线程安全性 1.懒汉式，线程不安全 这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程 12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 2.懒汉式，线程安全 这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步 优点：第一次调用才初始化，避免内存浪费 缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率 12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 3.饿汉式，线程安全(常用) 优点：没有加锁，执行效率会提高 缺点：类加载时就初始化，浪费内存 1234567public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 4.双重校验锁，线程安全 这种方式采用双锁机制，安全且在多线程情况下能保持高性能 1234567891011121314public class Singleton &#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; 2.工厂模式它提供了一种创建对象的最佳方式，在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象 意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 主要解决：主要解决接口选择的问题。 何时使用：我们明确地计划不同条件下创建不同实例时。 如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。 关键代码：创建过程在其子类执行。 应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。 优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。 缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。 3.抽象工厂模式抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象 意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 主要解决：主要解决接口选择的问题。 何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。 如何解决：在一个产品族里面，定义多个产品。 关键代码：在一个工厂里聚合多个同类产品。 应用实例：工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。 优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。 使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。 注意事项：产品族难扩展，产品等级易扩展。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F10%2F05%2FRedis%2F</url>
    <content type="text"><![CDATA[1.NoSQL1. 什么是NoSQL NoSQL = Not Only SQL 非关系型数据库 2.为什么要用NoSQL 高并发读写 海量数据的高效率存储和访问 高可扩展性和高可用性 2.Redis一个高性能的key-value数据库 Redis 与其他 key - value 缓存产品有以下三个特点： Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 1.支持的数据类型 String: 字符串类型 Hash：散列类型 List：列表类型 Set：集合类型 Sorted Set：有序集合类型 2.应用场景 缓存 任务队列 网站访问统计 数据过期处理 应用排行榜 分布式集群架构中的session分离 3.Redis持久化1.RDB持久化：可以在指定的时间间隔内将内存中的数据集快照写入磁盘 2.AOF持久化：记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集 3.RDB结合AOF：在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整 4.不持久化：你甚至可以关闭持久化功能，让数据只在服务器运行时存在 4.RDB的优点 RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。 RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心，或者亚马逊 S3 中。 RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。 RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。 5.RDB的缺点 如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。 每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， fork() 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端； 如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然 AOF 重写也需要进行 fork() ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。 6.AOF的优点 使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 fsync 同步策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync 。 AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。 AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 seek ， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， redis-check-aof 工具也可以轻易地修复这种问题。 Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。 AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。 7.AOF的缺点 对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。 根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。 AOF 在过去曾经发生过这样的 bug ： 因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。 （举个例子，阻塞命令 BRPOPLPUSH 就曾经引起过这样的 bug 。） 测试套件里为这种情况添加了测试： 它们会自动生成随机的、复杂的数据集， 并通过重新载入这些数据来确保一切正常。 虽然这种 bug 在 AOF 文件中并不常见， 但是对比来说， RDB 几乎是不可能出现这种 bug 的。 8.Redis的淘汰策略 volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰 volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰 volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰 allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰 allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 no-enviction（驱逐）：禁止驱逐数据]]></content>
  </entry>
  <entry>
    <title><![CDATA[synchronized和lock]]></title>
    <url>%2F2018%2F09%2F26%2Fsynchronized%E5%92%8Clock%2F</url>
    <content type="text"><![CDATA[1.synchronized和Lock的区别 类别 synchronized Lock 存在层次 Java的关键字 一个类 锁的释放 1.以获取锁的线程执行代码同步代码，释放锁。2，线程执行发生异常，jvm会让线程释放锁 在finally中必须释放锁，不然容易造成线程死锁 锁的获取 假设A线程获得锁，B线程等待，如果A线程阻塞，则B会一直等 分情况而定，Lock有多个获取锁的方式，线程不用一直等 锁状态 无法判断 可判断 锁类型 可重入，不可中断，非公平 可重入，可判断，可公平 性能 少量同步 大量同步 1.Lock Lock的几个方法 lock() 获取锁 unlock() 释放锁 trylock() 获得锁的状态，返回true和false tryLock(long time,TimeUnit unit) 比tryLock加了时间期限 lockInterruptibly() 2. synchronized3.乐观锁和悲观锁 乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。 悲观锁（Pessimistic Lock），正如其名，具有强烈的独占和排他特性。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。 悲观锁（适合多写场景） 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现 乐观锁（适合多读场景） 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。（compare and swap） 乐观锁的缺点 ABA问题 循环时间长开销大 只能保证一个共享变量的原子操作 4.Java线程阻塞的代价 java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统介入，需要在户态与核心态之间切换，这种切换会消耗大量的系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。 如果线程状态切换是一个高频操作时，这将会消耗很多CPU处理时间； 如果对于那些需要同步的简单的代码块，获取锁挂起操作消耗的时间比用户代码执行的时间还要长，这种同步策略显然非常糟糕的。 synchronized会导致争用不到锁的线程进入阻塞状态，所以说它是java语言中一个重量级的同步操纵，被称为重量级锁，为了缓解上述性能问题，JVM从1.5开始，引入了轻量锁与偏向锁，默认启用了自旋锁，他们都属于乐观锁。 5.重量级锁和轻量级锁1. 自旋锁 自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。但是线程自旋是需要消耗cup的，说白了就是让cup在做无用功，如果一直获取不到锁，那线程也不能一直占用cup自旋做无用功，所以需要设定一个自旋等待的最大时间。如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。 自旋锁的优缺点自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用cpu做无用功，占着XX不XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要cup的线程又不能获取到cpu，造成cpu的浪费。所以这种情况下我们要关闭自旋锁； 自旋锁时间阈值自旋锁的目的是为了占着CPU的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用CPU资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！JVM对于自旋周期的选择，jdk1.5这个限度是一定的写死的，在1.6引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时JVM还针对当前CPU的负荷情况做了较多的优化 如果平均负载小于CPUs则一直自旋 如果有超过(CPUs/2)个线程正在自旋，则后来线程直接阻塞 如果正在自旋的线程发现Owner发生了变化则延迟自旋时间（自旋计数）或进入阻塞 如果CPU处于节电模式则停止自旋 自旋时间的最坏情况是CPU的存储延迟（CPU A存储了一个数据，到CPU B得知这个数据直接的时间差） 自旋时会适当放弃线程优先级之间的差异 自旋锁的开启 JDK1.7后，去掉此参数，由jvm控制 2.重量级锁（synchronized） synchronized的作用 作用与方法时，锁住的是对象的实例 当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen（jdk1.8则metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程 synchronized作用于一个对象实例时，锁住的是所有以该对象为锁的代码块 synchronized的实现 3.偏向锁 Java偏向锁(Biased Locking)是Java6引入的一项多线程优化。偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。 如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。 4.轻量级锁 轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁；]]></content>
  </entry>
  <entry>
    <title><![CDATA[Oracle]]></title>
    <url>%2F2018%2F09%2F20%2FOracle%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[text]]></title>
    <url>%2F2018%2F09%2F14%2Ftext%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[idea官方快捷键]]></title>
    <url>%2F2018%2F09%2F14%2Fidea%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[摘要: idea官方快捷键 最开始很不习惯它自动保存，后面慢慢发现这样很好了。 你可以切到eclipse模式，然后找你常用的快捷键，看一下对于这个快捷键它是怎样说明的，记住后，再切换到默认，找下这个在IntelliJ IDEA是什么快捷键 因为IntelliJ IDEA的快捷键分类也分的不错的，这里主要你需要搞定两个：Editor Actions，Version Control System 自己学快捷键的经过：==Ctrl==Ctrl + Y 删除行ctrl + X 剪切行Ctrl + N 查找类Ctrl + R 替换Ctrl + O 选择可覆盖/继承的方法Ctrl + F 当前代码（文件）中查找Ctrl + J 自动代码提示（提示的是自己定义的代码格式）Ctrl + D 复制行或是块(默认是这个意思)(但是我一般习惯改成专门复制行,不包括块,搜索Duplicate Lines)Ctrl + P 方法参数提示显示Ctrl + W 选中光标所在的单词 ，连续按会有其他效果 (相反的是Ctrl+Shift+W)Ctrl + Q 鼠标放在变量/类名/方法名等上面（也可以在提示补充的时候按），显示文档内容，同类似的功能还有一个Ctrl + Shift + ICtrl + B 快速打开光标处的类或方法（对于前端支持很好,比如可以直接通过class的name定位到css的文件位置）(等同于ctrl+光标指向)Ctrl + E 最近打开的文件Ctrl + U 前往父类的方法/父类Ctrl + K VCS提交项目Ctrl + T VCS更新项目Ctrl + G 跳到指定行Ctrl + H 显示类层次图Ctrl + F1 显示错误Ctrl + F3 调转到所选中的词的下一个同名位置Ctrl + F9 编译Ctrl - F12 当前编辑的文件中快速导航(可以直接键入字母，IntelliJ IDEA会筛选你输入的来匹配对应是否有的方法，来快速定位)(类似结构图)Ctrl + F11 弹出一个小框来指定式添加书签(可以对文件或文件夹起作用)Ctrl + Tab 编辑窗口切换 (如果在切换的过程又加按上delete,则是关闭对应选中的窗口)Ctrl + delete 删除光标后面的单词Ctrl + home/end 跳到文件头文件尾Ctrl + BackSpace 删除光标前面的单词Ctrl + [ 或 ] 移动光标到块的初/末括号地方Ctrl + / 或 Ctrl+Shift+/ 注释（// 或者/…/ ）Ctrl + 1，2，3，4…. 快速定位到书签代码处(必须先Ctrl+Shift+1,2,3,4…添加书签)Ctrl + 空格 代码补全提示(因为windows默认被输入法给占用了,可以自己更改下)Ctrl + 小键盘+/- 折叠/展开代码Ctrl + 鼠标单击编辑窗口的文件标题 弹出该文件路径,可以通过这个打开文件所在地方(相当于Ctrl+alt+F12)Ctrl + 方向左/右 光标跳到上/下个单词 Ctrl + 方向上/下 相当于你用鼠标滑滚轮(为了方便鼠标党) ==Alt==Alt + 1 打开/关闭project选项卡?Alt + ?这个键是Tab上面那个，按下之后，如果项目有版本控制，则显示常用的版本控制命令Alt + A 在SVN中把新创建的文件加入进来（自己添加，在Subversion类别）Alt + Q 查看方法的声明(在左上角出现一个Tip层提示)，你无需滚动上去查看Alt + F1 弹出文件选择目标，这个很好用的Alt + F2 多个浏览器预览Alt + F3 选中文本，逐个往下查找相同文本，并高亮显示。Alt + F7 查看该方法/变量/类被调用的地方Alt + F8 在debug的状态下，选中某些变量或是对象，按此快捷键弹出可输入变量、方法的调试框，指定查看该内容的debug情况Alt + Home 跳到文件导航barAlt + Insert 生成代码(如get,set方法,构造函数等)Alt + 方向键 左 或 方向键 右 切换当前打开的代码文件视图Alt + 方向键 上 或 方向键 下 在方法间快速移动定位Alt + 鼠标左键单击不放,拖动 可以直接方块区域选择（很有用） Alt + 回车 快速修复(可以用来导入单个包) ==Shift==Shift + F6 重构：重新命名Shift + F11 查看书签Shift + F10 Run(运行)当前程序，相当于点击run按钮Shift + F9 ? debug当前程序，相当于点击debug按钮Shift + end 选中从光标到end处Shift + home 选中从光标到home处Shift + Enter 光标所在行下空出一行，光标跳下Shift + 单击 可以关闭文件 Shift + 滚轮 横向滚动轴滚动(非常强大) ==Ctrl+Alt==Ctrl + Alt + W 关闭所有编辑的快捷键（自己添加，在close all）Ctrl + Alt + O 优化导入的类和包Ctrl + Alt + L 格式化代码Ctrl + Alt + I 选中部分自动缩进行（有点类似格式化，但是只是整理行格式而已）Ctrl + Alt + T 选中的地方代码环绕提示Ctrl + Alt + B 跳到具体的实现方法，查找接口/抽象方法的具体实现很好用(相反行为的快捷键是Ctrl+b)Ctrl + Alt + V 快速引进一个变量Ctrl + Alt + F7 寻找被该类或是变量被使用的地方，用弹出框的方式找出来，跟Alt+F7效果一样，但是因为是弹出框，选中了一个位置就会消失。Ctrl + Alt + Enter 光标所在行上空出一行，光标跳上Ctrl + Alt + home 弹出跟当前文件有关联的文件目录(比如jsp里面有导入几个js和css,这些文件就是关联文件)Ctrl + Alt + 方向左/右 退回/前进到上一个操作的地方Ctrl + Alt + 方向上/下 在Find模式下，挑到上/下个查找的文件 Ctrl + Alt + 空格 类名或接口名提示(最常用的,一般敲入字母都会提示,但是如果你不小心esc了,可以再按这个出来)? ==Ctrl+Shift==Ctrl + Shift + F 查找整个项目相关关键字文件（非常非常常用）（通过某个词，指定要搜索的文件类型，目录（跟myeclipse中的ctrl+H功能一样））Ctrl + Shift + N通过文件名查找指定文件（非常非常常用）Ctrl + Shift + U // 大/小写都是这个快捷键Ctrl + Shift + B 在变量上按此快捷键，直接跳转到变量类型类中Ctrl + Shift + V 粘贴最近复制过的一些信息Ctrl + Shift + Z ，取消撤销（恢复上一次操作）Ctrl + Shift + T ? ? 如果在常规类下按它，弹出已写好的，可选择的对应Test类，如果在该Test类下按它，则直接回到源类。Ctrl + Shift + C 复制当前文件磁盘路径到剪贴板Ctrl + Shift + J 自动将下一行合并到当前行末尾Ctrl + Shift + E 最近更改的文件Ctrl + Shift + I ?在方法名或是类名下(或是代码补充提示的时候也可以按，也可以在图片地址上按)，按此快捷键显示该方法或是类的源码结构，无需点击进去查看源码（当然了，必须是你已经导入源码的情况下才看得到） 类似Ctrl+QCtrl + Shift + R 搜索指定范围文件，替换文字Ctrl + Shift + N 通过输入文件名（可以输入部分名称，支持模糊）来定位文件Ctrl + Shift + F12 编辑器全屏Ctrl + Shift + F7 高亮显示所有该选中文本，按Esc高亮消失。(也可以在throws或是try..catch上面按此快捷键，比如在一个方法的throws单词上按这个快捷键，则会把哪些内部方法会抛异常的都显出来)Ctrl + Shift + Del 删除环绕的标签Ctrl + Shift + 1，2，3… 快速添加书签Ctrl + Shift + Space 自动补全代码（智能提示）Ctrl + Shift + Enter 行末自动添加 ; 结束代码 ，如果是输入if，按这个快捷键会自动帮你补充(){}Ctrl + Shift + Enter 自动给末尾加;完成代码Ctrl + Shift + Up 或 Down 移动光标所在statement域移动到上面/下面(13版本会自动格式化)(如果光标放在方法名上 ，?是互换方法位置,如果是打开tool界面，且是竖直方向布局，则根据方向调整窗口大小)Ctrl + Shift + Left 或 Right 打开tool界面，如果是横向布局，则根据左右方向调整窗口大小)Ctrl + Shift + [ 或 ] 选中从光标所在位置到它的父级区域(界面上层导航可能更开)Ctrl + Shift + 小键盘 + 或 - 折叠/展开所有代码Ctrl + Shift + 空格 代码补全功能(最常用的,一般敲入字母都会提示,但是如果你不小心esc了,可以再按这个出来)Ctrl + Shift + 方向左 或 右 选中临边左/右的单词或是符号 Ctrl + Shift + Backspace(退格) ?回到上次修改的地方(跟Ctrl+Alt+左右方向键不一样的地方是，只回退到修改的地方，而不是过去光标放的地方) ==Alt+Shift==Alt + Shift + N 添加任务Alt + Shirt + F 添加到收藏夹Alt + Shift + C 查看最近操作项目的变化情况列表(在版本控制下，显示比较缓慢)Alt + Shift + F10 ?弹出run菜单，提供选择性run哪个(这个需要自己尝试下，按后会有弹出框，记得查看)Alt + Shift + F9 ?弹出debug运行菜单，提供选择性debug哪个(这个需要自己尝试下，按后会有弹出框，记得查看)Alt + Shift + 方向键 上 或 方向键 下 移动光标所在行到上/下 Alt + Shift + 双击 ? 同时在不同位置选定不同词 ==Ctrl+Shift+Alt==Ctrl + Shift + Alt + V? ? 简单黏贴Ctrl + Shift + Alt + N ? ?查找类中的方法或变量Ctrl + Shift + Alt + C ? 复制参考信息，比如在某个方法名上按此快捷键，得到的内容是：org.jfree.data.general.DefaultPieDataset#setValue(java.lang.Comparable, double)里面有包名，类名，方法名，方法变量]]></content>
  </entry>
  <entry>
    <title><![CDATA[刷题小结]]></title>
    <url>%2F2018%2F09%2F14%2F%E5%88%B7%E9%A2%98%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1.java 1.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？ JVM（Java虚拟机）是一个可以执行Java字节码的虚拟机进程。Java源程序先经过Javac编译器编译成.class字节码文件，再到jvm上运行，Java解释器会把其解释成对应的平台的机器码执行，所以Java的跨平台就是在不同平台上安装了不同的jvm。 JDK和JRE的区别是什么？ Java运行时环境(JRE) 它包括Java虚拟机、Java核心类库和支持文件 Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具 Java支持的数据类型有哪些？什么是自动拆装箱？ int,short,byte,long,float,double,boolean,char 链表，增删易，查找难 数组，查找容易 final类型的变量一定要初始化 JDBC（Java DataBase Connectivity）,是一套面向对象的应用程序接口（API），制定了统一的访问各类关系数据库的标准接口，为各个数据库厂商提供了标准的实现。通过JDBC技术，开发人员可以用纯Java语言和标准的SQL语句编写完整的数据库应用程序，并且真正地实现了软件的跨平台性。 PreparedStaement和Statements PreparedStatement是预编译的，PreparedStatement实例包涵已编译的sql语句，所以其执行呢速度要快于statement对象 PreparedStatement作为statement的子类，继承了statement的所有方法，三种方法，excute,excuteQuery和excuteUpdate已被更改以使之不再需要参数 PreparedStatement的代码可读性，可维护性强于statement 极大的提高了安全性 数据库连接的建立、关闭资源消耗巨大。 传统数据库访问方式：一次数据访问对应一个物理连接，每次操作数据库都要打开关闭该物理连接，系统性能严重受损。 解决方案：数据库连接池。系统初始运行时，主动建立足够的连接，组成一个池，每次应用程序请求数据库连接时，无需重新打开连接，而是从池中取出已有的连接，使用完后，不再关闭，而是归还 Vector和 ArrayList 同步性:Vector是线程安全的，也就是说是同步的(stack,hashtable,enumeration也是线程同步的) ，而ArrayList 是线程序不安全的，不是同步的 HashMap和HashTable HashMap允许键和值是null，而Hashtable不允许键和值是null HashTable是线程安全的，HashMap是非线程安全的。 Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。 因为线程安全的问题，HashMap效率比HashTable的要高 关于HashMap的一些说法： HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。HashMap的底层结构是一个数组，数组中的每一项是一条链表。 HashMap的实例有俩个参数影响其性能： “初始容量” 和 装填因子。 HashMap中的key-value都是存储在Entry中的 HashMap实现不同步，线程不安全 HashMap可以存null键和null值，不保证元素的顺序恒久不变，它的底层使用的是数组和链表，通过hashCode()方法和equals方法保证键的唯一性 解决冲突主要有三种方法：定址法，拉链法，再散列法。HashMap是采用拉链法解决哈希冲突的。 注： 链表法是将相同hash值的对象组成一个链表放在hash值对应的槽位； 用开放定址法解决冲突的做法是：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。 沿此序列逐个单元地查找，直到找到给定 的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。 拉链法解决冲突的做法是： 将所有关键字为同义词的结点链接在同一个单链表中 。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于1，但一般均取α≤1。拉链法适合未规定元素的大小 Hashtable和HashMap的区别: 继承不同。 public class Hashtable extends Dictionary implements Map public class HashMap extends AbstractMap implements Map Hashtable中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了 Hashtable 中， key 和 value 都不允许出现 null 值。 在 HashMap 中， null 可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为 null 。当 get() 方法返回 null 值时，即可以表示 HashMap 中没有该键，也可以表示该键所对应的值为 null 。因此，在 HashMap 中不能由 get() 方法来判断 HashMap 中是否存在某个键， 而应该用 containsKey() 方法来判断 两个遍历方式的内部实现上不同。Hashtable、HashMap都使用了Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值 Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。 注： HashSet子类依靠hashCode()和equal()方法来区分重复元素。 HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，这也是HashSet中元素不能重复的原因。而Map中保存key值的,会去判断当前Map中是否含有该Key对象，内部是先通过key的hashCode,确定有相同的hashCode之后，再通过equals方法判断是否相同。 1.首先，需要明白类的加载顺序。 (1) 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法) (2) 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 ) (3) 父类非静态代码块( 包括非静态初始化块，非静态属性 ) (4) 父类构造函数 (5) 子类非静态代码块 ( 包括非静态初始化块，非静态属性 ) (6) 子类构造函数 Servlet的生命周期一般用三个方法来表示 init()：仅执行一次，负责在装载Servlet时初始化Servlet对象 service() ：核心方法，一般HttpServlet中会有get,post两种处理方式。在调用doGet和doPost方法时会构造servletRequest和servletResponse请求和响应对象作为参数。 destroy()：在停止并且卸载Servlet时执行，负责释放资源 初始化阶段：Servlet启动，会读取配置文件中的信息，构造指定的Servlet对象，创建ServletConfig对象，将ServletConfig作为参数来调用init()方法 try-catch-finnally finally里的代码必须执行，假如finally中有return则返回finally里的 存在try和finally并且try中有return而finally没有，则先执行try中return之前的代码，然后执行finally中的代码，最后执行try中的return 当try中发生异常，catch和finally都有return时，先执行try中发生异常之前的代码，再执行catch里return之前的代码，最后执行finally并返回finally中的return 捕获到的异常不仅可以在当前方法中处理，还可以将异常抛给调用它的上一级方法来处理 程序运行时异常由Java虚拟机自动进行处理，非运行异常可捕获和抛出 构造方法 构造方法一定要与定义为public的类同名 构造方法没有返回值 构造方法也是类的方法，可以在创建对象时为成员变量赋值 构造方法可以进行重载，但是参数列表必须不相同，不以返回值和访问级别进行区分 非静态方法只能通过实例对象来调用，不能直接通过类名调用。静态方法（static）才能通过类名直接调用 静态内部类不可以直接访问外围类的非静态数据，而非静态内部类可以直接访问外围类的数据，包括私有数据 java不允许单独的方法，过程或函数存在,需要隶属于某一类中 大多数 JVM 将内存区域划分为 Method Area（Non-Heap）（方法区） ,Heap（堆） , Program Counter Register（程序计数器） , VM Stack（虚拟机栈，也有翻译成JAVA 方法栈的）,Native Method Stack （ 本地方法栈 ），其中Method Area 和 Heap 是线程共享的 ，VM Stack，Native Method Stack 和Program Counter Register 是非线程共享的。为什么分为 线程共享和非线程共享的呢?请继续往下看。 首先我们熟悉一下一个一般性的 Java 程序的工作过程。一个 Java 源程序文件，会被编译为字节码文件（以 class 为扩展名），每个java程序都需要运行在自己的JVM上，然后告知 JVM 程序的运行入口，再被 JVM 通过字节码解释器加载运行。那么程序开始运行后，都是如何涉及到各内存区域的呢？ 概括地说来，JVM初始运行的时候都会分配好 Method Area（方法区） 和Heap（堆） ，而JVM 每遇到一个线程，就为其分配一个 Program Counter Register（程序计数器） , VM Stack（虚拟机栈）和Native Method Stack （本地方法栈）， 当线程终止时，三者（虚拟机栈，本地方法栈和程序计数器）所占用的内存空间也会被释放掉。这也是为什么我把内存区域分为线程共享和非线程共享的原因，非线程共享的那三个区域的生命周期与所属线程相同，而线程共享的区域与JAVA程序运行的生命周期相同，所以这也是系统垃圾回收的场所只发生在线程共享的区域（实际上对大部分虚拟机来说知发生在Heap上）的原因 Java中的volatile关键字的功能 1，可见性 可见性指的是在一个线程中对该变量的修改会马上由工作内存（Work Memory）写回主内存（Main Memory），所以会马上反应在其它线程的读取操作中。顺便一提，工作内存和主内存可以近似理解为实际电脑中的高速缓存和主存，工作内存是线程独享的，主存是线程共享的。 2，禁止指令重排序优化 禁止指令重排序优化。大家知道我们写的代码（尤其是多线程代码），由于编译器优化，在实际执行的时候可能与我们编写的顺序不同。编译器只保证程序执行结果与源代码相同，却不保证实际指令的顺序与源代码相同。这在单线程看起来没什么问题，然而一旦引入多线程，这种乱序就可能导致严重问题。volatile关键字就可以从语义上解决这个问题 出于运行速率的考虑，java编译器会把经常经常访问的变量放到缓存（严格讲应该是工作内存）中，读取变量则从缓存中读。但是在多线程编程中,内存中的值和缓存中的值可能会出现不一致。volatile用于限定变量只能从内存中读取，保证对所有线程而言，值都是一致的。但是volatile不能保证原子性，也就不能保证线程安全 final声明的类不能被继承 forward和redirect是最常问的两个问题 forward，服务器获取跳转页面内容传给用户，用户地址栏不变 redirect，是服务器向用户发送转向的地址，redirect后地址栏变成新的地址 1，新生代：（1）所有对象创建在新生代的Eden区，当Eden区满后触发新生代的Minor GC，将Eden区和非空闲Survivor区存活的对象复制到另外一个空闲的Survivor区中。（2）保证一个Survivor区是空的，新生代Minor GC就是在两个Survivor区之间相互复制存活对象，直到Survivor区满为止。 2，老年代：当Survivor区也满了之后就通过Minor GC将对象复制到老年代。老年代也满了的话，就将触发Full GC，针对整个堆（包括新生代、老年代、持久代）进行垃圾回收。3，持久代：持久代如果满了，将触发Full GC4.System.gc() public &gt; protected &gt; 同包（default） &gt; private structs基于MVC模式 静态初始化块&gt;初始化块&gt;构造方法&gt;普通方法 静态优先，父类优先 %和优先级相同，顺序执行，10%3=1 12=2 count是静态变量，被所有对象共享 ConcurrentHashMap使用segment来分段和管理锁，segment继承自ReentrantLock，因此ConcurrentHashMap使用ReentrantLock来保证线程安全 Arrays.asList() 将一个数组转化为一个List对象，这个方法会返回一个ArrayList类型的对象， 这个ArrayList类并非java.util.ArrayList类，而是Arrays类的静态内部类！用这个对象对列表进行添加删除更新操作，就会报UnsupportedOperationException异常 先出现字符串，后面的内容自动强制转换为string进行拼接 先出现数字，则进行加减运算 先算括号里面，数字 byte能表示的范围[-128,127] ThreadLocal的类 ThreadLocal并没有继承自Thread，也没有实现Runnable接口 ThreadLocal是采用哈希表的方式来为每个线程都提供一个变量的副本 ThreadLocal保证各个线程间数据安全，每个线程的数据是数据的独立不会被另外线程访问和破坏 round方法，它表示“四舍五入”Math.round(11.5)=12,Math.round(-11.5)=-11” 后台线程：指为其他线程提供服务的线程，也称为守护线程。JVM的垃圾回收线程就是一个后台线程。 前台线程：是指接受后台线程服务的线程 “编译看左边，运行看右边”。也就是编译时候，会看左边引用类型是否能正确编译通过，运行的时候是调用右边的对象的方法 类变量在不设置初始值时，会进行默认值赋值，而局部方法中声明的变量则必须进行初始化，他不会进行默认值赋值 值传递和引用传递： 值传递：方法调用时，实际参数把它的值传递给对应的形式参数，形式参数只是用实际参数的值初始化自己的存储单元内容，是两个不同的存储单元，所以方法执行中形式参数值的改变不影响实际参数的值 引用传递：也称为传地址。方法调用时，实际参数是对象(或数组)，这时实际参数与形式参数指向同一个地址，在方法执行中，对形式参数的操作实际上就是对实际参数的操作，这个结果在方法结束后被保留了下来，所以方法执行中形式参数的改变将会影响实际参数 抽象类总结 区别1：抽象类体现继承关系，一个类只能単继承。接口体现实现关系，一个类可以多实现 区别2：抽象类中可以定义非抽象方法和抽象方法，子类继承后可以直接使用非抽象方法。接口的方法都是抽象的，必须由子类去实现。接口中的成员都有固定的修饰符 区别3：抽象类有构造方法，用于给子类对象初始化。而接口没有构造方法 特点1：抽象类不可以实例化，即不能用new创建对象。抽象类必须由其子类覆盖了所有的抽象方法后， 该子类才可以实例化，否则，这个子类也是抽象类 特点2：抽象类abstract关键字不能和哪些关键字共存: final 因为final修饰的方法不能被继承。 static因为类.方法（），此方法没有方法体，没有意义。 private 因为抽象方法是要被子类覆盖的，加上private子类就不知道这个方法了。 特点3：接口中声明变量必须是final、public 、static的，接口中定义的方法都是abstract、 public的。接口里的数据成员必须初始化，且全是常量，不是变量。 特点4：接口是抽象类的 *变体（* 你没看错 *），* 接口也可以通过关键字extends来继承其他接口。格式如下所示： class 类名称 implements 接口A，接口B{ //接口的实现} interface 子接口名称 extends 父接口1，父接口2，...{} 线程调度分为协同式调度和抢占式调度，Java使用的是抢占式调度，也就是每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定（协同式调度）。这就是平台独立的原因 自动装箱(自动拆装箱JDK需在1.5上） 基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true 两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述 两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true 基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringMvc]]></title>
    <url>%2F2018%2F09%2F14%2FSpringmvc%2F</url>
    <content type="text"><![CDATA[1框架原理和入门配置1.什么是SpringMVC springmvc是spring框架的一个模块，springmvc和spring无需通过中间整合层进行整合。（struts2与Spring整合的时候需要借助单独的jar包） springmvc是一个基于mvc的web框架。 2.MVC在b/s系统下的应用 ###3.SpringMVC框架原理 步骤 发起请求到前端控制器 (DispatcherServlet) 前端控制器请求处理器映射器 (HandlerMapping) 查找 Handler (可根据 xml 配置、注解进行查找) 处理器映射器 (HandlerMapping) 向前端控制器返回 Handler 前端控制器调用处理器适配器 (HandlerAdapter) 执行 Handler 处理器适配器 (HandlerAdapter) 去执行 Handler Handler 执行完，给适配器返回 ModelAndView (SpringMVC 框架的一个底层对象) 处理器适配器 (HandlerAdapter) 向前端控制器返回 ModelAndView 前端控制器 (DispatcherServlet) 请求视图解析器 (ViewResolver) 进行视图解析，根据逻辑视图名解析成真正的视图 (jsp) 视图解析器 (ViewResolver) 向前端控制器 (DispatcherServlet) 返回 View 前端控制器进行视图渲染，即将模型数据 (在 ModelAndView 对象中)填充到 request 域 前端控制器向用户响应结果 组件及其作用 前端控制器 (DispatcherServlet) 接收请求，响应结果，相当于转发器，中央处理器。 有了DispatcherServlet减少了其他组件之间的耦合度 处理器映射器 (HandlerMapping) 作用：根据请求的 url 查找 Handler 处理器 (Handler) 注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler 处理器适配器 (HandlerAdapter) 作用：按照特定规则（HandlerAdapter要求的规则）执行Handler。 视图解析器 (ViewResolver) 作用：进行视图解析，根据逻辑视图解析成真正的视图 (View) 视图 (View) View 是一个接口实现类支持不同的 View 类型（jsp,pdf等等） 2.mybatis1.mybatis之SqlSession SqlSession的作用 向SQL语句传入参数 执行SQL语句 获取执行后的结果 事务控制 如何得到SQLSession 通过配置文件获取数据库连接相关信息 通过配置文件信息构建SqlSessionFactory 通过SqlSessionFactory打开数据库对话]]></content>
  </entry>
  <entry>
    <title><![CDATA[玩转数据结构]]></title>
    <url>%2F2018%2F09%2F14%2F%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[1.数组1.数组的定义数组是一种常见的数据类型，用于存储多个相同数据类型的集合。 2.数组的创建方式123456//数组的创建方式1int[] a = &#123;1,2,3&#125;;//方式2int[] b = new int[]&#123;1,2,3&#125;;//方式3int[] c = new int[3]; 3.向数组中添加，查询搜索和删除元素4.动态数组 数组动态伸缩 数组扩容，缩容 5.时间复杂度 算法的时间复杂度是一个函数，它定性描述了该算法的运行时间 均摊复杂度 复杂度震荡 2.栈和队列1.栈 栈（stack）又名堆栈，它是一种线性表 ，先进后出，从栈顶添加元素，栈顶取出 ###2.栈的应用 撤销操作，就相当于一个先进后出 程序调用的系统栈 括号匹配，用栈解决问题 3.队列 队列也是一种线性结构，先进先出。 数组队列 循环队列 front表示队首的元素 tail表示队尾下一个元素的位置 3.链表 链表是一种最简单的，真正的动态数据结构 优点 真正的动态，不需要处理固定容量问题 缺点 丧失了随机访问的能力 节点装载元素，节点连接 链表实现栈，链表头做栈顶 链表实现队列，链表头取元素，链表尾部插入元素 4.链表与递归1.递归 递归通常就是把一个原问题转化为一个规模较小的问题 递归调用是有代价的：函数调用+系统栈空间 2.二分搜索树二叉树 二分搜索树是特殊的二叉树 二叉树前序遍历 首先访问根节点 然后访问根节点的左子树 然后访问根节点的右子树 中序遍历 先访问左子树 再访问节点 后访问右子树 中序遍历后是从小到大的排序结果 后序遍历 先访问左子树 再访问右子树 后访问根节点 非递归遍历需要借助栈Stack 3.深度优先遍历（DFS） 前中后序遍历本质都是dfs 4.广度优先遍历（BFS） 也叫层序遍历 5.排序基础1.冒泡排序 基本原理 从第一个数据开始，与第二个数据相比较，如果第二个数据小于第一个数据，则交换两个数据的位置 指针由第一个数据移向第二个数据，第二个数据与第三个数据相比较，如果第三个数据小于第二个数据，则交换两个数据的位置 依此类推，完成第一轮排序。第一轮排序结束后，最大的元素被移到了最右面 依照上面的过程进行第二轮排序，将第二大的排在倒数第二的位置 重复上述过程，没排完一轮，比较次数就减少一次 共进行n-1轮排序 编码思路： 需要两层循环，第一层循环i表示排序的轮数，第二层循环j表示比较的次数 冒泡排序算法总结 N个元素需要排序N-1轮 第i轮需要比较N-i次 N个元素比较，需要比较n(n-1)/2次 冒泡排序算法复杂度较高O(n*n) 2.选择排序 选择排序是对冒泡排序的改进，比较次数和冒泡排序相同，但是交换次数要小于冒泡排序，时间复杂度为O(n*n) 基本原理： 从第一个元素开始，分别与后面的元素向比较，找到最小的元素与第一个元素交换位置 从第二个元素开始，分别与后面的元素相比较，找到剩余元素中最小的元素，与第二个元素交换 重复上述步骤，直到所有的元素都排成由小到大为止 编码思路： 需要两次循环，第一层循环i表示每轮指针指向的位置，将最小值min初始化为第i个元素，第二层循环从j=i+1开始，分别与min比较，如果小于min，则更新min的值，内层循环结束后；交换min元素和第i个元素的位置。以此类推进行下一轮循环，直到i=length时停止循环。当i=length时，说明小的元素已经全部移到了左面，因此无需进行内层循环了 选择排序总结 N个元素需要排序N-1轮 第i轮需要比较N-i次 N个元素排序，需要比较n（n-1）/2次 选择排序的算法复杂度仍为O（n*n） 相比于冒泡排序，选择排序的交换次数大大减少，因此速度要快于冒泡排序 3.插入排序 插入排序是简单排序中最快的排序算法，虽然时间复杂度仍然为O(n*n)，但是却比冒泡排序和选择排序快很多 基本原理： 将指针指向某个元素，假设该元素左侧的元素全部有序，将该元素抽取出来，然后按照从右往左的顺序分别与其左边的元素比较，遇到比其大的元素便将元素右移，直到找到比该元素小的元素或者找到最左面发现其左侧的元素都比它大，停止 此时会出现一个空位，将该元素放入到空位中，此时该元素左侧的元素都比它小，右侧的元素都比它大 指针向后移动一位，重复上述过程。每操作一轮，左侧有序元素都增加一个，右侧无序元素都减少一个 编码分析： 需要两层循环，第一层循环index表示上述例子中的指针，即遍历从坐标为1开始的每一个元素；第二层循环从leftindex=index-1开始，leftindex–向左遍历，将每一个元素与i处的元素比较，直到j处的元素小于i出的元素或者leftindex&lt;0；遍历从i到j的每一个元素使其右移，最后将index处的元素放到leftindex处的空位处 插入排序总结： 插入排序的速度约比冒泡排序快一倍（比较次数少一倍），比选择排序还要快一些，对于基本有序的数据，插入排序的速度会很快，是简单排序中效率最高的排序算法 4.希尔排序 希尔排序属于插入类排序,是将整个有序序列分割成若干小的子序列分别进行插入排序 基本原理： 希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快） 步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作（且步长要小于数组长度）。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序 5.归并排序 O(nlogN) 归并排序 (merge sort) 是一类与插入排序、交换排序、选择排序不同的另一种排序方法。归并的含义是将两个或两个以上的有序表合并成一个新的有序表, 将两个或者两个以上的有序表合并成一个新的有序表，即把待排序的序列分成若干个子序列,每个序列是有序的，然后把有序序列合并成整体有序序列 是一种稳定排序方式 6.快速排序 算法思路： 设置两个变量i、j，排序开始的时候：i=0，j=N-1 以第一个数组元素作为关键数据，赋值给key，即key=A[0] 从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换 从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换 重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束） 7.堆排序 了解堆 二叉堆是一颗完全二叉树（最大堆） 堆中的某节点的值总是小于其父节点的值（大顶堆） ##8.树，森林，二叉树的转换 将树或者森林转换成对应的二叉树方法： 在所有的兄的节点之间添加一条连线，如果是森林，则在其所有树的树根之间同样添加一条连线。 对于树，森林的每个节点，除保留其到第一个子女的连线外，撤销其到其他子女的连线 将以上得到的树按顺时针旋转45° 得到对应的二叉树 二叉树到森林的转换 上述过程的逆过程 3-&gt;2-&gt;1. 9.线性表的检索（查找）1.顺序检索 从线性表的头扫描到尾部 2.二分法检索（折半查找nlog2n） 条件：只适用于顺序存储结构 找到中间节点，判断大于还是小于，取前半段还是后半段，再取半段中的中间节点，判断，重复进行，直到找到为止。 3.分块检索 结合顺序查找和二分查找 基本思想： 将线性表分为若干块，在每一块中，结点的存放不一定有序，但块与块之间必须是分块有序的 4.二叉排序树5.丰满树和平衡二叉排序树（AVL树) 丰满树： 满足任意两个非孩子节点的高度之差的绝对值小于等于1 平衡二叉树具有的性质： 它的左子树和右子树都是平衡二叉树，且左子树和右子树高度之差的绝对值不超过1（可以是空树） 平衡因子即平衡二叉树的左右子树高度差，可取-1，0，1 左子树深度减去右子树的为平衡因子 平衡二叉树的高度节点数量之间的关系也是O(logn) 6.AVL树的插入算法描述 目的：维护平衡 若AVL树t为空树，则插入一个数据元素为x的新节点作为t的根结点，树的深度为1. 若x和AVL树的根节点关键字相同，则不插入。 若x的关键字小于AVL树得根结点，分以下三种情况处理： 若AVL树的根结点的平衡因子为-1，则将根结点的平衡因子调节为0，树的深度不表。 若AVL树的根节点的平衡因子为0，则将根结点的平衡因子调节为1，树的深度加一 若AVL树的平衡因子为1，则当改左子树根结点为1时，需要进行LL平衡旋转，当该树的左子树的根结点平衡因子为-1时需要LR平衡旋转。 若x关键字大于根节点，则将x插入到该树的右子树，并且当插入后的右子树深度增加1时，参考（3）按情况处理. 7.B-树和B+树 B-树：一种适合于外查找的树 一颗m阶B树是一棵m路平衡搜索树，或者是空树，满足以下性质。 根结点至少有两个子女 每个非根节点所包含的关键字个数 n 满足：[m/2]-1&lt;=n&lt;=m-1 除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故内部子树个数 k 满足：[m/2]&lt;= k &lt;= m 所有的叶子结点都位于同一层 B+树：m阶B+树结构定义 树中每个结点至多有m棵子树 除根结点之外的每个结点至少有[m/2]棵子树 若根结点不是叶子节点且非空，则至少有2棵子树 所有的叶子结点包含全部关键字及指向相应记录的指针，而且叶子结点按关键字大小顺序链接（可以把每个叶子节点看成一个基本索引块，它的指针不在指向另一级索引，而是直接指向数据文件中的记录） B树和B+树区别： 为什么是B+树而不是B树呢，因为它内节点不存储data，这样一个节点就可以存储更多的key B+树上增加了顺序访问指针，也就是每个叶子节点增加一个指向相邻叶子节点的指针，这样一棵树成了数据库系统实现索引的首选数据结构 10.树的总结一、二叉查找树（1）二叉树简介： 二叉查找树也称为有序二叉查找树，满足二叉查找树的一般性质，是指一棵空树具有如下性质： 1、任意节点左子树不为空,则左子树的值均小于根节点的值； 2、任意节点右子树不为空,则右子树的值均大于于根节点的值； 3、任意节点的左右子树也分别是二叉查找树； 4、没有键值相等的节点；上图为一个普通的二叉查找树，按照中序遍历的方式可以从小到大的顺序排序输出：2、3、5、6、7、8。 对上述二叉树进行查找，如查键值为5的记录，先找到根，其键值是6，6大于5，因此查找6的左子树，找到3；而5大于3，再找其右子树；一共找了3次。如果按2、3、5、6、7、8的顺序来找同样需求3次。用同样的方法在查找键值为8的这个记录，这次用了3次查找，而顺序查找需要6次。计算平均查找次数得：顺序查找的平均查找次数为（1+2+3+4+5+6）/ 6 = 3.3次，二叉查找树的平均查找次数为（3+3+3+2+2+1）/6=2.3次。二叉查找树的平均查找速度比顺序查找来得更快。 （2）局限性及应用 一个二叉查找树是由n个节点随机构成，所以，对于某些情况，二叉查找树会退化成一个有n个节点的线性链。如下图：大家看上图，如果我们的根节点选择是最小或者最大的数，那么二叉查找树就完全退化成了线性结构。上图中的平均查找次数为（1+2+3+4+5+5）/6=3.16次，和顺序查找差不多。显然这个二叉树的查询效率就很低，因此若想最大性能的构造一个二叉查找树，需要这个二叉树是平衡的（这里的平衡从一个显著的特点可以看出这一棵树的高度比上一个输的高度要大，在相同节点的情况下也就是不平衡），从而引出了一个新的定义-平衡二叉树AVL。 ###二、AVL树 （1）简介 AVL树是带有平衡条件的二叉查找树，一般是用平衡因子差值判断是否平衡并通过旋转来实现平衡，左右子树树高不超过1，和红黑树相比，它是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差不超过1）。不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而旋转是非常耗时的，由此我们可以知道AVL树适合用于插入删除次数比较少，但查找多的情况。从上面是一个普通的平衡二叉树，这张图我们可以看出，任意节点的左右子树的平衡因子差值都不会大于1。 （2）局限性 由于维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果应用场景中对插入删除不频繁，只是对查找要求较高，那么AVL还是较优于红黑树。 （3）应用 1、Windows NT内核中广泛存在； ###三、红黑树 （1）简介 一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是red或black。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍。它是一种弱平衡二叉树(由于是若平衡，可以推出，相同的节点情况下，AVL树的高度低于红黑树)，相对于要求严格的AVL树来说，它的旋转次数变少，所以对于搜索、插入、删除操作多的情况下，我们就用红黑树。 （2）性质 1、每个节点非红即黑；2、根节点是黑的；3、每个叶节点(叶节点即树尾端NULL指针或NULL节点)都是黑的；4、如果一个节点是红的,那么它的两儿子都是黑的；5、对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点；6、每条路径都包含相同的黑节点； （3）应用 1、广泛用于C++的STL中，Map和Set都是用红黑树实现的；2、著名的Linux进程调度Completely Fair Scheduler，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一颗红黑树上，每个虚拟地址区域都对应红黑树的一个节点，左指针指向相邻的地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间；3、IO多路复用epoll的实现采用红黑树组织管理sockfd，以支持快速的增删改查；4、Nginx中用红黑树管理timer，因为红黑树是有序的，可以很快的得到距离当前最小的定时器；5、Java中TreeMap的实现； ###四、B/B+树 说了上述的三种树：二叉查找树、AVL和红黑树，似乎我们还没有摸到MySQL为什么要使用B+树作为索引的实现，不要急，接下来我们就先探讨一下什么是B树。 （1）简介 我们在MySQL中的数据一般是放在磁盘中的，读取数据的时候肯定会有访问磁盘的操作，磁盘中有两个机械运动的部分，分别是盘片旋转和磁臂移动。盘片旋转就是我们市面上所提到的多少转每分钟，而磁盘移动则是在盘片旋转到指定位置以后，移动磁臂后开始进行数据的读写。那么这就存在一个定位到磁盘中的块的过程，而定位是磁盘的存取中花费时间比较大的一块，毕竟机械运动花费的时候要远远大于电子运动的时间。当大规模数据存储到磁盘中的时候，显然定位是一个非常花费时间的过程，但是我们可以通过B树进行优化，提高磁盘读取时定位的效率。 为什么B类树可以进行优化呢？我们可以根据B类树的特点，构造一个多阶的B类树，然后在尽量多的在结点上存储相关的信息，保证层数尽量的少，以便后面我们可以更快的找到信息，磁盘的I/O操作也少一些，而且B类树是平衡树，每个结点到叶子结点的高度都是相同，这也保证了每个查询是稳定的。 总的来说，B/B+树是为了磁盘或其它存储设备而设计的一种平衡多路查找树(相对于二叉，B树每个内节点有多个分支)，与红黑树相比，在相同的的节点的情况下，一颗B/B+树的高度远远小于红黑树的高度(在下面B/B+树的性能分析中会提到)。B/B+树上操作的时间通常由存取磁盘的时间和CPU计算时间这两部分构成，而CPU的速度非常快，所以B树的操作效率取决于访问磁盘的次数，关键字总数相同的情况下B树的高度越小，磁盘I/O所花的时间越少。 注意B-树就是B树，-只是一个符号。 （2）B树的性质 1、定义任意非叶子结点最多只有M个儿子，且M&gt;2；2、根结点的儿子数为[2, M]；3、除根结点以外的非叶子结点的儿子数为[M/2, M]；4、每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）5、非叶子结点的关键字个数=指向儿子的指针个数-1；6、非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；7、非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；8、所有叶子结点位于同一层；这里只是一个简单的B树，在实际中B树节点中关键字很多的，上面的图中比如35节点，35代表一个key(索引)，而小黑块代表的是这个key所指向的内容在内存中实际的存储位置，是一个指针。 ###五、B+树 （1）简介 B+树是应文件系统所需而产生的一种B树的变形树（文件的目录一级一级索引，只有最底层的叶子节点（文件）保存数据）非叶子节点只保存索引，不保存实际的数据，数据都保存在叶子节点中，这不就是文件系统文件的查找吗? 我们就举个文件查找的例子：有3个文件夹a、b、c， a包含b，b包含c，一个文件yang.c，a、b、c就是索引（存储在非叶子节点）， a、b、c只是要找到的yang.c的key，而实际的数据yang.c存储在叶子节点上。 所有的非叶子节点都可以看成索引部分！ （2）B+树的性质(下面提到的都是和B树不相同的性质) 1、非叶子节点的子树指针与关键字个数相同；2、非叶子节点的子树指针p[i],指向关键字值属于[k[i],k[i+1]]的子树.(B树是开区间,也就是说B树不允许关键字重复,B+树允许重复)；3、为所有叶子节点增加一个链指针；4、所有关键字都在叶子节点出现(稠密索引). (且链表中的关键字恰好是有序的)；5、非叶子节点相当于是叶子节点的索引(稀疏索引),叶子节点相当于是存储(关键字)数据的数据层；6、更适合于文件系统； 非叶子节点（比如5，28，65）只是一个key（索引），实际的数据存在叶子节点上（5，8，9）才是真正的数据或指向真实数据的指针。 （3）应用 1、B和B+树主要用在文件系统以及数据库做索引，比如MySQL； ###六、B/B+树性能分析 n个节点的平衡二叉树的高度为H(即logn)，而n个节点的B/B+树的高度为logt((n+1)/2)+1；若要作为内存中的查找表，B树却不一定比平衡二叉树好，尤其当m较大时更是如此。因为查找操作CPU的时间在B-树上是O(mlogtn)=O(lgn(m/lgt))，而m/lgt&gt;1；所以m较大时O(mlogtn)比平衡二叉树的操作时间大得多。因此在内存中使用B树必须取较小的m。（通常取最小值m=3，此时B-树中每个内部结点可以有2或3个孩子，这种3阶的B-树称为2-3树）。 ###七、为什么说B+树比B树更适合数据库索引？ 1、 B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。 2、B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 3、由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。 PS：我在知乎上看到有人是这样说的,我感觉说的也挺有道理的： 他们认为数据库索引采用B+树的主要原因是：B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。 今天看了几篇文章，自己总结一下。 数据库使用B+树肯定是为了提升查找效率。 但是具体如何提升查找效率呢？ 查找数据，最简单的方式是顺序查找。但是对于几十万上百万，甚至上亿的数据库查询就很慢了。 所以要对查找的方式进行优化，熟悉的二分查找，二叉树可以把速度提升到O(log(n,2))，查询的瓶颈在于树的深度，最坏的情况要查找到二叉树的最深层，由于，每查找深一层，就要访问更深一层的索引文件。在多达数G的索引文件中，这将是很大的开销。所以，尽量把数据结构设计的更为‘矮胖’一点就可以减少访问的层数。在众多的解决方案中，B-/B+树很好的适合。B-树定义具体可以查阅，简而言之就是中间节点可以多余两个子节点，而且中间的元素可以是一个域。相比B-树，B+树的父节点也必须存在于子节点中，是其中最大或者最小元素，B+树的节点只存储索引key值，具体信息的地址存在于叶子节点的地址中。这就使以页为单位的索引中可以存放更多的节点。减少更多的I/O支出。因此，B+树成为了数据库比较优秀的数据结构，MySQL中MyIsAM和InnoDB都是采用的B+树结构。不同的是前者是非聚集索引，后者主键是聚集索引，所谓聚集索引是物理地址连续存放的索引，在取区间的时候，查找速度非常快，但同样的，插入的速度也会受到影响而降低。聚集索引的物理位置使用链表来进行存储。 11.图1.图的基本概念 顶点 无向边，无向图 有向边，有向图 权值 网：带权值的图 子图 度，出度，入度 连通图：图中任意两个顶点都是连通的。 2.图的存储结构 邻接矩阵：用两个数组，一个数组保存顶点集，一个数组保存边集。 3.图的遍历 深度优先遍历（DFS）：从图中某个顶点v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到。 广度优先遍历（BFS）：假设从C0出发，接着访问C0的邻接点C1和C2，依次访问与C1邻接的未曾访问的C3和C4，然后访问与C2邻接未曾访问的C5，直到全部访问。 4.最小生成树 基本概念 普里姆算法（prim） 克鲁斯卡尔算法（kruskal） 5.最短路径 （Dijkstra）：把图中的顶点集合V分成两组，第一组为已求出最短路径的顶点集合S（初始时S中只有源节点，以后每求得一条最短路径，就将它对应的顶点加入到集合S中，直到全部顶点都加入到S中）；第二组是未确定最短路径的顶点集合U。 算法步骤： （1）初始化时，S只含有源节点； （2）从U中选取一个距离v最小的顶点k加入S中（该选定的距离就是v到k的最短路径长度）； （3）以k为新考虑的中间点，修改U中各顶点的距离；若从源节点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值是顶点k的距离加上k到u的距离； （4）重复步骤（2）和（3），直到终点在S中]]></content>
  </entry>
  <entry>
    <title><![CDATA[spring]]></title>
    <url>%2F2018%2F09%2F14%2FSpring%2F</url>
    <content type="text"><![CDATA[Spring 分层： web层： struts，springmvc service层：spring dao层：hibernate，mybatis，jdbcTemplate，spring-data 1.什么是Spring spring是一个基于IOC和APO的结构的J2EE系统的轻量级框架，Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情 ，它的核心主要是ioc和aop。 IOC（Inversion Of Control）反转控制是spring的基础，简单地说就是创造对象由以前的程序员自己new构造方法来调用，变成了交由spring创建对象。 DI依赖注入（Dependency Inject），简单地说就是拿到对象的属性，已经被注入好相关值了，直接使用即可。 2.IOC思想： 其思想是反转资源获取的方向，传统的资源查找方式要求组件向容器发起请求查找资源，作为应答，容器适时的返回资源，而应用了IOC后，则是容器主动的将资源推送给它所在的管理组件，组件所要做的仅是选择一种合适的方式来接受资源，这种行为也被称为查找的被动形式。 IOC（Inversion Of Control）反转控制是spring的基础，简单地说就是创造对象由以前的程序员自己new构造方法来调用，变成了交由spring创建对象。 Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下： ●谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。 ●为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。 AOP（Aspect Oriented Programming ）面向切面，AOP主要实现的目的是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果 ，通俗点讲就是提供一个为一个业务实现提供切面注入的机制，通过这种方式，在业务运行中将定义好的切面通过切入点绑定到业务中，以实现将一些特殊的逻辑绑定到此业务中 。 首先，在面向切面编程的思想里面，把功能分为核心业务功能，和周边功能 所谓的核心业务，比如登陆，增加数据，删除数据都叫核心业务 所谓的周边功能，比如性能统计，日志，事务管理等等 周边功能在Spring的面向切面编程AOP思想里，即被定义为切面 在面向切面编程AOP的思想里面，核心业务功能和切面功能分别独立进行开发,然后把切面功能和核心业务功能 “编织” 在一起，这就叫AOP 核心容器：bean，core，context，expression 3.Spring的优点 方便解耦，简化开发（高内聚低耦合) Spring就是一个大工厂（容器），可以将所有的对象创建和依赖关系维护，交给Spring管理 spring工厂是用于生成bean 。 AOP编程的支持 Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能 声明式事务的支持 只需要通过配置就可以完成对事务的管理，而无需手动编程 方便程序的测试 Spring对Junit4支持，可以通过注解方便的测试Spring程序 方便集成各种优秀框架 Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz等）的直接支持 降低JavaEE API的使用难度 Spring 对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低 4.Spring的3种配置方式 基于XML的配置 基于注解的配置 基于Java的配置 2.配置Bean 配置形式：基于XML文件的方式，基于注解的方式 Bean的配置方式：通过反射，通过工厂方法，FactoryBean IOC容器 1.Spring容器 在SpringIOC容器读取Bean配置创建Bean实例之前必须对他进行实例化，只有容器实例化后，才可以从IOC容器里获取Bean实例并使用。 Spring提供两种类型的IOC容器实现 BeanFactory：IOC容器的基本实现 ApplicationContext：提供更多高级的特性，是BeanFactory的子接口 BeanFactory是Spring框架的基础设施，面向spring本身，ApplicationContext面向Spring框架的开发者，几乎所有的应用场合直接都用ApplicationContext而非BeanFactory。 无论什么方式，配置文件相同 12345678//1.创建Spring的IOC容器对象//ApplicationContext 代表容器//ClassPathXmlApplicationContext 是 ApplicationContext 接口的实现类：从类路径加载配置文件ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");//2.从IOC容器中获取bean实例//利用id定位到IOC容器中的BeanHelloWorld helloWorld = (HelloWorld) ctx.getBean("helloworld"); 2.依赖注入的方式###1，setter注入 属性注入即通过setter方法注入Bean的属性值或依赖的对象 属性注入使用property元素，使用name属性指定Bean的属性名称，value属性指定属性值 属性注入是最常用的注入方式 123&lt;bean id="helloworld" class="com.HelloWorld"&gt; &lt;property name="name2" value="Spring"&gt;&lt;/property&gt;&lt;/bean&gt; ###2，构造器注入 通过构造方法注入Bean的属性值或依赖的对象，它保证了Bean实例在实例化后就可以使用。 构造器注入元素声明属性 ###3，工厂方法注入 4，Bean之间的引用 在Bean配置文件中，通过&lt; ref &gt;元素或ref属性为Bean的属性指定对Bean的引用 内部Bean 在Bean引用时在自己内部构建一个Bean 不能被外部Bean引用 级联属性赋值： 集合属性配置（list和map集合和Properties） 使用Utility scheme 定义集合（外部bean可用） 通过p 命名空间为Bean的属性赋值 3.自动装配1.XML配置的Bean自动装配 Spring IOC容器可以自动装配Bean，需要做的就是仅仅在的autowire属性里指定自动装配的模式 byType(根据类型自动装配)：若IOC容器中有多个与目标Bean类型一致的Bean，在这种情况下，Spring将无法判哪个合适，所以不能自动装配。 byName(根据名称自动装配)：必须将目标Bean的名称和属性名设置完全相同 123&lt;!--自动匹配装配autowire--&gt;&lt;bean id=&quot;person&quot; class=&quot;out.Person&quot;p:name=&quot;小哥&quot; autowire=&quot;byType&quot;&gt; 2.继承Bean配置 子Bean可以覆盖从父Bean继承过来的配置 并不是《bean》元素里的所有属性都会被继承 3.Bean之间的依赖 4.Bean的作用域 定义一个作用域 当定义一个 在Spring里，我们还能给这个bean声明一个作用域。它可以通过bean 定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope 属性 必须设为 singleton。 Spring支持的几种bean的作用域 singleton : bean在每个Spring ioc 容器中只有一个实例 prototype：一个bean的定义可以有多个实例 request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。 session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。 global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效 5.Bean的生命周期Spring Bean的生命周期简单易懂。在一个bean实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个bean不在被调用时需要进行相关的析构操作，并从bean容器中移除。 Spring bean factory 负责管理在spring容器中被创建的bean的生命周期。Bean的生命周期由两组回调（call back）方法组成 初始化之后调用的回调方法。 销毁之前调用的回调方法。 Spring容器 从XML 文件中读取bean的定义，并实例化bean。 Spring根据bean的定义填充所有的属性。 调用Bean的初始化方法。 bean就可以使用了 当容器关闭时，调用Bean的销毁方法 在Bean的声明里设置init-method和destroy-method属性，为Bean指定初始化和销毁方法。]]></content>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用hexo+github搭建免费博客]]></title>
    <url>%2F2018%2F09%2F12%2F%E5%88%A9%E7%94%A8hexo%2Bgithub%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一、准备工作： 注册一个github账号 ：支持高亮代码块、LaTeX 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手； 安装node.js ：下载链接https://pan.baidu.com/s/1xTBWJ-FFqe6_UfpYezuBtA 安装git ：下载链接https://pan.baidu.com/s/1FdgU2wjgF4RXQc5JRXrxbw 安装node.js和git ：只需要按默认next就ok了。 node.js环境配置：参考链接中的步骤https://www.jianshu.com/p/03a76b2e7e00 二、开始： 创建blog文件夹、并安装hexo、创建github仓库：在你的某个盘符下根目录创建一个blog空文件夹，操作步骤参考下面链接中的步骤3和4https://www.cnblogs.com/fengxiongZz/p/7707219.html 配置SSH key：参考下面链接中的步骤3https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html和参考下面链接中的步骤5https://www.cnblogs.com/fengxiongZz/p/7707219.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[helloJava]]></title>
    <url>%2F2018%2F09%2F12%2Fjava%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.继承 java类中只有单继承 Object类是所有类的父类，默认继承，Object类中的方法适合所有子类 1.参数 定义方法时的参数称为形参，调用方法时的参数称为实参 2.重载 判断方法重载的依据： 必须是在同一个类中 方法名相同 方法参数的个数，顺序或类型不同 与方法的修饰符或返回值没有关系， 覆盖和重载：覆盖只发生在父类和子类之间，而重载可以发生在同一个类 重写（覆盖）：子类可以继承父类的方法，但是子类对父类的方法不满意，可以重写父类继承的方法，当调用方法时会优先调用子类的方法 Java 会根据参数的个数和类型来判断应该调用哪个重载方法，参数完全匹配的方法将被执行 3.局部变量和成员变量 局部变量是定义在方法中，作用域仅在方法中，Java不会给局部变量一个初始值 成员变量在类中，作用域在整个类，java会给成员变量一个初始值 4.static关键字 静态变量可以直接使用类名直接访问，非静态变量则需要创建一个类的对象来调用该变量静态的方法 静态初始化块&gt;初始化块&gt;构造方法&gt;普通方法 类方法是指类中被static修饰的方法 123456789101112131415161718192021222324252627public class Statickuai &#123; String name; String sex; static int age; //构造方法 public Statickuai()&#123; System.out.println("通过构造方法初始化name"); name = "tom"; &#125; //初始化块 &#123; System.out.println("通过初始化块初始化sex"); sex = "男"; &#125; //静态初始化块 static &#123; System.out.println("通过静态初始化快初始化age"); age = 20; &#125; public void show()&#123; System.out.println(name+sex+age); &#125; public static void main(String[] args) &#123; Statickuai hi=new Statickuai(); hi.show(); &#125;&#125; 5.封装 修改属性的可见性：设为private .创建getter/setter方法：用于属性的读写 .在getter/setter方法中加入属性控制语句：对属性值的合法性进行判断 优点：1，只能通过规定的方法访问数据 2，隐藏类的实例细节，方便修改 6.内部类 成员内部类 静态内部类 匿名内部类 方法内部类 7.final关键字 修饰类则不允许被继承 修饰方法则不允许被重写 修饰属性则该类的属性不会进行隐式的初始化（自己赋值0.0）或在构造方法中赋值 修饰变量则就是常量，必须初始化且不可更改 8.super关键字 子类的构造的过程必须调用其父类的构造方法 如果子类的构造方法中没有显示调用父类得构造方法，系统默认调用父类无参的构造方法 如果显示的调用构造方法，必须在子类的构造方法的第一行 如果子类构造方法中既没有显示调用父类的构造方法，而又没有无参的构造方法，则出错 调用父类属性 super.age 调用父类方法 super.eat() 9.equals和== equals： 比较的是对象的引用是否指向同一块内存地址 重写equals方法来达到比较两个对象的属性值和方法是否相同 10.多态11.抽象类 抽象类前使用abstract关键字修饰abstract class 抽象方法没有方法体以;结束 抽象类不能被实例化 限制实现某些子类必须实现的某些方法，不关注具体实现的细节 抽象类关注它的存在性，是什么 12.接口 若要实现一个接口为普通类则必须实现接口的所有抽象方法 接口下的方法只能是抽象方法 接口类的使用必须由接口的实现类来实现 接口 对象名=new 接口的实现类 13.异常 运行时异常：Exception 非运行时异常：error try，catch，throw try用于检测包裹的代码块是否出现异常，如有异常，则抛出异常。 catch用于捕获从try中抛出的异常并做处理 throw用于抛出异常 throws关键字可以在方法上声明该方法要抛出的异常，然后再方法内部通过throw抛出异常对象。 14.String和StringBuilder String 对象存储字符串的效率比 StringBuilder 高 在需要频繁对字符串进行修改操作时使用 StringBuilder 的效率比 String 要高 2.容器，集合基本概念 Collection接口：定义了存取一组对象的方法，其子接口Set和List分别定义了存储方式。 List：有序可重复 Set：无序不可重复 Map接口定义了存储 ” 键（key）——值（Value）“映射对的方法 3.多线程 什么是线程，什么是进程 进程就是一个启动的程序，而线程就是程序里执行操作的控制单元 线程创建的三种方式 继承Thread类 实现runnable接口 匿名内部类 实现方式和继承方式有什么区别： 实现方式避免了单继承的局限性 继承Thread:线程代码存放在Thread子类的run方法中 实现Runnable：线程代码存放在接口的子类的run方法中 常见的线程方法 sleep 当前线程暂停 join 加入到当前线程中 setPriority 线程优先级 yield 临时暂停 setDaemon 守护线程 同步（并发） 多线程的同步问题指的是多个线程同时修改一个数据的时候，可能导致的问题 使用synchronized解决同步问题，synchronized表示当前线程，独占对象 someObject 当前线程独占 了对象someObject，如果有其他线程试图占有对象someObject，就会等待，直到当前线程释放对someObject的占用。 someObject 又叫同步对象，所有的对象，都可以作为同步对象 为了达到同步的效果，必须使用同一个同步对象 关键字synchronized解决办法1.同步代码块：synchronized（对象） { 需要被同步的代码 } 2.synchronized修饰： 如果一个类，其方法都是有synchronized修饰的，那么该类就叫做线程安全的类 死锁 wait()和notify()方法进行线程交互 线程池 Lock接口对象解决同步问题 与 synchronized (someObject) 类似的，lock()方法，表示当前线程占用lock对象，一旦占用，其他线程就不能占用了。 与 synchronized 不同的是，一旦synchronized 块结束，就会自动释放对someObject的占用。 lock却必须调用unlock方法进行手动释放，为了保证释放的执行，往往会把unlock() 放在finally中进行。 总结Lock和synchronized的区别 Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现，Lock是代码层面的实现。 Lock可以选择性的获取锁，如果一段时间获取不到，可以放弃。synchronized不行，会一根筋一直获取下去。 借助Lock的这个特性，就能够规避死锁，synchronized必须通过谨慎和良好的设计，才能减少死锁的发生。 synchronized在发生异常和同步块结束的时候，会自动释放锁。而Lock必须手动释放， 所以如果忘记了释放锁，一样会造成死锁。 4.Hibernate JDBC 数据库的crud操作 预编译Statement 和 Statement一样，PreparedStatement也是用来执行sql语句的 这是JAVA里唯二的基1的地方，另一个是查询语句中的ResultSet也是基1的 Statement 需要进行字符串拼接，可读性和维护性比较差 ，PreparedStatement 使用参数设置，可读性好，不易犯错 PreparedStatement有预编译机制，性能比Statement更快 execute和executeUpdate 相同点：都可以执行增加，删除，修改 不同点： execute可以执行查询语句 然后通过getResultSet，把结果集取出来 executeUpdate不能执行查询语句 execute返回boolean类型，true表示执行的是查询语句，false表示执行的是insert,delete,update等等 executeUpdate返回的是int，表示有多少条数据受到了影响 hibernate实际是对jdbc的一种封装 ORM（object relational mapping）对象关系映射 MVC思想 （model view controller）模型 视图 控制器 实体类对象在Hibernate中有3种状态 瞬时：指的是没有和hibernate发生任何关系，在数据库中也没有对应的记录，一旦JVM结束，这个对象也就消失了 持久：指得是一个对象和hibernate发生联系，有对应的session,并且在数据库中有对应的一条记录 托管：指的是一个对象虽然在数据库中有对应的一条记录，但是它所对应的session已经关闭了 HQL ( hibernate query language ) hibernate专门用于查询数据的语句 使用Criteria查询 与HQL和SQL的区别是Criteria 完全是 面向对象的方式在进行数据查询，将不再看到有sql语句的痕迹 Criteria 还可以很方便的进行进行和获取总数 关系 一对一 共享主键方式：就是限制两个数据表的主键使用相同的值，通过主键形成一对一映射关系 唯一外键方式：就是一个表中的外键和另一个表中的唯一主键对应形成一对一映射关系 多对一 一对多 多对多 事务 Hibernate的任何对数据有改动的操作，都应该被放在事务里面 ，在事务中的多个操作行为，要么都成功，要么都失败 延迟加载 属性的延迟加载: 当使用load的方式来获取对象的时候，只有访问了这个对象的属性，hibernate才会到数据库中进行查询。否则不会访问数据库 比如有的页面只需要显示分类信息，这个时候倘若没有开启延迟加载，那么就会把分类下的产品也查询出来了，增加了不必要的开销 什么是级联 ：简单的说，没有配置级联的时候，删除分类，其对应的产品不会被删除。 但是如果配置了恰当的级联，那么删除分类的时候，其对应的产品都会被删除掉 缓存 Hibernate的一级缓存是在Session上（默认开启），二级缓存是在SessionFactory上 两种获取方式 load方式是延迟加载，只有属性被访问的时候才会调用sql语句 get方式是非延迟加载，无论后面的代码是否会访问到属性，马上执行sql语句 代码比较复制代码 注解 hibernate里常用注解包括，类注解，属性注解，关系注解，其他的注解 5.网络编程 使用Socket进行不同程序间的通信 建立连接 服务端开启端口并监听，时刻等待客户端的连接请求 客户端知道服务端的ip地址和监听端口号，发出请求到服务端 客户端的端口地址是系统分配的，一旦建立连接，服务器会得到一个新的Socket对象，该对象负责与客户端进行通信 6.Struts2 Javaweb三层框架 web层：表示层，主要架构模式为MVC，主要框架有Spring MVC和Struts2 Service层：业务逻辑层，主要框架有Spring Dao层：数据访问层，主要框架有：MyBatis和Hibernate SSH：Struts2 + Spring + Hibernate SSM：Spring MVC + Spring + MyBatis（目前更流行） struts2是基于MVC的Web框架 7.注解 Annotation的作用： 不是程序本身，可以对程序做出解释（这一点和注释没什么区别） 可以被其他程序读取（注解信息处理流程，是注解和注释最大的区别。如果没有注解信息处理流程，则注解毫无意义） Annotation的格式 注解是以 @注释名 在代码中存在的，还可以添加一些参数值例如：@SuppressWarnings（value =”unchecked“) 基本内置注解 @Override @Deprecated @SuppressWarnings Suppress 等等 自定义注解 创建注解类型的时候即不使用class也不使用interface,而是使用@interface public @interface JDBCConfig 元注解 @Target({METHOD,TYPE}) 表示这个注解可以用用在类/接口上，还可以用在方法上 @Retention(RetentionPolicy.RUNTIME) 表示这是一个运行时注解，即运行起来之后，才获取注解中的相关信息，而不像基本注解如@override那种不用运行，在编译时eclipse就可以进行相关工作的编译时注解。 @Inherited 表示这个注解可以被子类继承 注解元素，这些注解元素就用于存放注解信息，在解析的时候获取出来]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Javase</tag>
      </tags>
  </entry>
</search>
