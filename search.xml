<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F09%2F14%2Fidea%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[ժҪ: idea�ٷ���ݼ� �ʼ�ܲ�ϰ�����Զ����棬�����������������ܺ��ˡ� ������е�eclipseģʽ��Ȼ�����㳣�õĿ�ݼ�����һ�¶��������ݼ���������˵���ģ���ס�����л���Ĭ�ϣ����������IntelliJ IDEA��ʲô��ݼ� ��ΪIntelliJ IDEA�Ŀ�ݼ�����Ҳ�ֵĲ���ģ�������Ҫ����Ҫ�㶨������Editor Actions��Version Control System �Լ�ѧ��ݼ��ľ�����==Ctrl==Ctrl + Y ɾ����ctrl + X ������Ctrl + N ������Ctrl + R �滻Ctrl + O ѡ��ɸ���/�̳еķ���Ctrl + F ��ǰ���루�ļ����в���Ctrl + J �Զ�������ʾ����ʾ�����Լ�����Ĵ����ʽ��Ctrl + D �����л��ǿ�(Ĭ���������˼)(������һ��ϰ�߸ĳ�ר�Ÿ�����,��������,����Duplicate Lines)Ctrl + P ����������ʾ��ʾCtrl + W ѡ�й�����ڵĵ��� ����������������Ч�� (�෴����Ctrl+Shift+W)Ctrl + Q �����ڱ���/����/�����������棨Ҳ��������ʾ�����ʱ�򰴣�����ʾ�ĵ����ݣ�ͬ���ƵĹ��ܻ���һ��Ctrl + Shift + ICtrl + B ���ٴ򿪹�괦����򷽷�������ǰ��֧�ֺܺ�,�������ֱ��ͨ��class��name��λ��css���ļ�λ�ã�(��ͬ��ctrl+���ָ��)Ctrl + E ����򿪵��ļ�Ctrl + U ǰ������ķ���/����Ctrl + K VCS�ύ��ĿCtrl + T VCS������ĿCtrl + G ����ָ����Ctrl + H ��ʾ����ͼCtrl + F1 ��ʾ����Ctrl + F3 ��ת����ѡ�еĴʵ���һ��ͬ��λ��Ctrl + F9 ����Ctrl - F12 ��ǰ�༭���ļ��п��ٵ���(����ֱ�Ӽ�����ĸ��IntelliJ IDEA��ɸѡ���������ƥ���Ӧ�Ƿ��еķ����������ٶ�λ)(���ƽṹͼ)Ctrl + F11 ����һ��С����ָ��ʽ�����ǩ(���Զ��ļ����ļ���������)Ctrl + Tab �༭�����л� (������л��Ĺ����ּӰ���delete,���ǹرն�Ӧѡ�еĴ���)Ctrl + delete ɾ��������ĵ���Ctrl + home/end �����ļ�ͷ�ļ�βCtrl + BackSpace ɾ�����ǰ��ĵ���Ctrl + [ �� ] �ƶ���굽��ĳ�/ĩ���ŵط�Ctrl + / �� Ctrl+Shift+/ ע�ͣ�// ����/…/ ��Ctrl + 1��2��3��4…. ���ٶ�λ����ǩ���봦(������Ctrl+Shift+1,2,3,4…�����ǩ)Ctrl + �ո� ���벹ȫ��ʾ(��ΪwindowsĬ�ϱ����뷨��ռ����,�����Լ�������)Ctrl + С����+/- �۵�/չ������Ctrl + ��굥���༭���ڵ��ļ����� �������ļ�·��,����ͨ��������ļ����ڵط�(�൱��Ctrl+alt+F12)Ctrl + ������/�� ���������/�¸����� Ctrl + ������/�� �൱��������껬����(Ϊ�˷�����굳) ==Alt==Alt + 1 ��/�ر�projectѡ�?Alt + ?�������Tab�����Ǹ�������֮�������Ŀ�а汾���ƣ�����ʾ���õİ汾��������Alt + A ��SVN�а��´������ļ�����������Լ���ӣ���Subversion���Alt + Q �鿴����������(�����Ͻǳ���һ��Tip����ʾ)�������������ȥ�鿴Alt + F1 �����ļ�ѡ��Ŀ�꣬����ܺ��õ�Alt + F2 ��������Ԥ��Alt + F3 ѡ���ı���������²�����ͬ�ı�����������ʾ��Alt + F7 �鿴�÷���/����/�౻���õĵط�Alt + F8 ��debug��״̬�£�ѡ��ĳЩ�������Ƕ��󣬰��˿�ݼ���������������������ĵ��Կ�ָ���鿴�����ݵ�debug���Alt + Home �����ļ�����barAlt + Insert ���ɴ���(��get,set����,���캯����)Alt + ����� �� �� ����� �� �л���ǰ�򿪵Ĵ����ļ���ͼAlt + ����� �� �� ����� �� �ڷ���������ƶ���λAlt + ��������������,�϶� ����ֱ�ӷ�������ѡ�񣨺����ã� Alt + �س� �����޸�(�����������뵥����) ==Shift==Shift + F6 �ع�����������Shift + F11 �鿴��ǩShift + F10 Run(����)��ǰ�����൱�ڵ��run��ťShift + F9 ? debug��ǰ�����൱�ڵ��debug��ťShift + end ѡ�дӹ�굽end��Shift + home ѡ�дӹ�굽home��Shift + Enter ����������¿ճ�һ�У��������Shift + ���� ���Թر��ļ� Shift + ���� ������������(�ǳ�ǿ��) ==Ctrl+Alt==Ctrl + Alt + W �ر����б༭�Ŀ�ݼ����Լ���ӣ���close all��Ctrl + Alt + O �Ż��������Ͱ�Ctrl + Alt + L ��ʽ������Ctrl + Alt + I ѡ�в����Զ������У��е����Ƹ�ʽ��������ֻ�������и�ʽ���ѣ�Ctrl + Alt + T ѡ�еĵط����뻷����ʾCtrl + Alt + B ���������ʵ�ַ��������ҽӿ�/���󷽷��ľ���ʵ�ֺܺ���(�෴��Ϊ�Ŀ�ݼ���Ctrl+b)Ctrl + Alt + V ��������һ������Ctrl + Alt + F7 Ѱ�ұ�������Ǳ�����ʹ�õĵط����õ�����ķ�ʽ�ҳ�������Alt+F7Ч��һ����������Ϊ�ǵ�����ѡ����һ��λ�þͻ���ʧ��Ctrl + Alt + Enter ����������Ͽճ�һ�У��������Ctrl + Alt + home ��������ǰ�ļ��й������ļ�Ŀ¼(����jsp�����е��뼸��js��css,��Щ�ļ����ǹ����ļ�)Ctrl + Alt + ������/�� �˻�/ǰ������һ�������ĵط�Ctrl + Alt + ������/�� ��Findģʽ�£�����/�¸����ҵ��ļ� Ctrl + Alt + �ո� ������ӿ�����ʾ(��õ�,һ��������ĸ������ʾ,��������㲻С��esc��,�����ٰ��������)? ==Ctrl+Shift==Ctrl + Shift + F ����������Ŀ��عؼ����ļ����ǳ��ǳ����ã���ͨ��ĳ���ʣ�ָ��Ҫ�������ļ����ͣ�Ŀ¼����myeclipse�е�ctrl+H����һ������Ctrl + Shift + Nͨ���ļ�������ָ���ļ����ǳ��ǳ����ã�Ctrl + Shift + U // ��/Сд���������ݼ�Ctrl + Shift + B �ڱ����ϰ��˿�ݼ���ֱ����ת��������������Ctrl + Shift + V ճ��������ƹ���һЩ��ϢCtrl + Shift + Z ��ȡ���������ָ���һ�β�����Ctrl + Shift + T ? ? ����ڳ������°�����������д�õģ���ѡ��Ķ�ӦTest�࣬����ڸ�Test���°�������ֱ�ӻص�Դ�ࡣCtrl + Shift + C ���Ƶ�ǰ�ļ�����·����������Ctrl + Shift + J �Զ�����һ�кϲ�����ǰ��ĩβCtrl + Shift + E ������ĵ��ļ�Ctrl + Shift + I ?�ڷ���������������(���Ǵ��벹����ʾ��ʱ��Ҳ���԰���Ҳ������ͼƬ��ַ�ϰ�)�����˿�ݼ���ʾ�÷����������Դ��ṹ����������ȥ�鿴Դ�루��Ȼ�ˣ����������Ѿ�����Դ�������²ſ��õ��� ����Ctrl+QCtrl + Shift + R ����ָ����Χ�ļ����滻����Ctrl + Shift + N ͨ�������ļ������������벿�����ƣ�֧��ģ��������λ�ļ�Ctrl + Shift + F12 �༭��ȫ��Ctrl + Shift + F7 ������ʾ���и�ѡ���ı�����Esc������ʧ��(Ҳ������throws����try..catch���水�˿�ݼ���������һ��������throws�����ϰ������ݼ���������Щ�ڲ����������쳣�Ķ��Գ���)Ctrl + Shift + Del ɾ�����Ƶı�ǩCtrl + Shift + 1��2��3… ���������ǩCtrl + Shift + Space �Զ���ȫ���루������ʾ��Ctrl + Shift + Enter ��ĩ�Զ���� ; �������� �����������if���������ݼ����Զ����㲹��(){}Ctrl + Shift + Enter �Զ���ĩβ��;��ɴ���Ctrl + Shift + Up �� Down �ƶ��������statement���ƶ�������/����(13�汾���Զ���ʽ��)(��������ڷ������� ��?�ǻ�������λ��,����Ǵ�tool���棬������ֱ���򲼾֣�����ݷ���������ڴ�С)Ctrl + Shift + Left �� Right ��tool���棬����Ǻ��򲼾֣���������ҷ���������ڴ�С)Ctrl + Shift + [ �� ] ѡ�дӹ������λ�õ����ĸ�������(�����ϲ㵼�����ܸ���)Ctrl + Shift + С���� + �� - �۵�/չ�����д���Ctrl + Shift + �ո� ���벹ȫ����(��õ�,һ��������ĸ������ʾ,��������㲻С��esc��,�����ٰ��������)Ctrl + Shift + ������ �� �� ѡ���ٱ���/�ҵĵ��ʻ��Ƿ��� Ctrl + Shift + Backspace(�˸�) ?�ص��ϴ��޸ĵĵط�(��Ctrl+Alt+���ҷ������һ���ĵط��ǣ�ֻ���˵��޸ĵĵط��������ǹ�ȥ���ŵĵط�) ==Alt+Shift==Alt + Shift + N �������Alt + Shirt + F ��ӵ��ղؼ�Alt + Shift + C �鿴���������Ŀ�ı仯����б�(�ڰ汾�����£���ʾ�Ƚϻ���)Alt + Shift + F10 ?����run�˵����ṩѡ����run�ĸ�(�����Ҫ�Լ������£�������е����򣬼ǵò鿴)Alt + Shift + F9 ?����debug���в˵����ṩѡ����debug�ĸ�(�����Ҫ�Լ������£�������е����򣬼ǵò鿴)Alt + Shift + ����� �� �� ����� �� �ƶ���������е���/�� Alt + Shift + ˫�� ? ͬʱ�ڲ�ͬλ��ѡ����ͬ�� ==Ctrl+Shift+Alt==Ctrl + Shift + Alt + V? ? �����Ctrl + Shift + Alt + N ? ?�������еķ��������Ctrl + Shift + Alt + C ? ���Ʋο���Ϣ��������ĳ���������ϰ��˿�ݼ����õ��������ǣ�org.jfree.data.general.DefaultPieDataset#setValue(java.lang.Comparable, double)�����а���������������������������]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F09%2F14%2F%E5%88%B7%E9%A2%98%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[##1.java 1.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？ JVM（Java虚拟机）是一个可以执行Java字节码的虚拟机进程。Java源程序先经过Javac编译器编译成.class字节码文件，再到jvm上运行，Java解释器会把其解释成对应的平台的机器码执行，所以Java的跨平台就是在不同平台上安装了不同的jvm。 JDK和JRE的区别是什么？ Java运行时环境(JRE) 它包括Java虚拟机、Java核心类库和支持文件 Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具 Java支持的数据类型有哪些？什么是自动拆装箱？ int,short,byte,long,float,double,boolean,char 链表，增删易，查找难 数组，查找容易 final类型的变量一定要初始化 JDBC（Java DataBase Connectivity）,是一套面向对象的应用程序接口（API），制定了统一的访问各类关系数据库的标准接口，为各个数据库厂商提供了标准的实现。通过JDBC技术，开发人员可以用纯Java语言和标准的SQL语句编写完整的数据库应用程序，并且真正地实现了软件的跨平台性。 PreparedStaement和Statements PreparedStatement是预编译的，PreparedStatement实例包涵已编译的sql语句，所以其执行呢速度要快于statement对象 PreparedStatement作为statement的子类，继承了statement的所有方法，三种方法，excute,excuteQuery和excuteUpdate已被更改以使之不再需要参数 PreparedStatement的代码可读性，可维护性强于statement 极大的提高了安全性 数据库连接的建立、关闭资源消耗巨大。 传统数据库访问方式：一次数据访问对应一个物理连接，每次操作数据库都要打开关闭该物理连接，系统性能严重受损。 解决方案：数据库连接池。系统初始运行时，主动建立足够的连接，组成一个池，每次应用程序请求数据库连接时，无需重新打开连接，而是从池中取出已有的连接，使用完后，不再关闭，而是归还 Vector和 ArrayList 同步性:Vector是线程安全的，也就是说是同步的(stack,hashtable,enumeration也是线程同步的) ，而ArrayList 是线程序不安全的，不是同步的 HashMap和HashTable HashMap允许键和值是null，而Hashtable不允许键和值是null HashTable是线程安全的，HashMap是非线程安全的。 Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。 因为线程安全的问题，HashMap效率比HashTable的要高 关于HashMap的一些说法： HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。HashMap的底层结构是一个数组，数组中的每一项是一条链表。 HashMap的实例有俩个参数影响其性能： “初始容量” 和 装填因子。 HashMap中的key-value都是存储在Entry中的 HashMap实现不同步，线程不安全 HashMap可以存null键和null值，不保证元素的顺序恒久不变，它的底层使用的是数组和链表，通过hashCode()方法和equals方法保证键的唯一性 解决冲突主要有三种方法：定址法，拉链法，再散列法。HashMap是采用拉链法解决哈希冲突的。 注： 链表法是将相同hash值的对象组成一个链表放在hash值对应的槽位； 用开放定址法解决冲突的做法是：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。 沿此序列逐个单元地查找，直到找到给定 的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。 拉链法解决冲突的做法是： 将所有关键字为同义词的结点链接在同一个单链表中 。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于1，但一般均取α≤1。拉链法适合未规定元素的大小 Hashtable和HashMap的区别: 继承不同。 public class Hashtable extends Dictionary implements Map public class HashMap extends AbstractMap implements Map Hashtable中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了 Hashtable 中， key 和 value 都不允许出现 null 值。 在 HashMap 中， null 可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为 null 。当 get() 方法返回 null 值时，即可以表示 HashMap 中没有该键，也可以表示该键所对应的值为 null 。因此，在 HashMap 中不能由 get() 方法来判断 HashMap 中是否存在某个键， 而应该用 containsKey() 方法来判断 两个遍历方式的内部实现上不同。Hashtable、HashMap都使用了Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值 Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。 注： HashSet子类依靠hashCode()和equal()方法来区分重复元素。 HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，这也是HashSet中元素不能重复的原因。而Map中保存key值的,会去判断当前Map中是否含有该Key对象，内部是先通过key的hashCode,确定有相同的hashCode之后，再通过equals方法判断是否相同。 1.首先，需要明白类的加载顺序。 (1) 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法) (2) 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 ) (3) 父类非静态代码块( 包括非静态初始化块，非静态属性 ) (4) 父类构造函数 (5) 子类非静态代码块 ( 包括非静态初始化块，非静态属性 ) (6) 子类构造函数 Servlet的生命周期一般用三个方法来表示 init()：仅执行一次，负责在装载Servlet时初始化Servlet对象 service() ：核心方法，一般HttpServlet中会有get,post两种处理方式。在调用doGet和doPost方法时会构造servletRequest和servletResponse请求和响应对象作为参数。 destroy()：在停止并且卸载Servlet时执行，负责释放资源 初始化阶段：Servlet启动，会读取配置文件中的信息，构造指定的Servlet对象，创建ServletConfig对象，将ServletConfig作为参数来调用init()方法 try-catch-finnally finally里的代码必须执行，假如finally中有return则返回finally里的 存在try和finally并且try中有return而finally没有，则先执行try中return之前的代码，然后执行finally中的代码，最后执行try中的return 当try中发生异常，catch和finally都有return时，先执行try中发生异常之前的代码，再执行catch里return之前的代码，最后执行finally并返回finally中的return 捕获到的异常不仅可以在当前方法中处理，还可以将异常抛给调用它的上一级方法来处理 程序运行时异常由Java虚拟机自动进行处理，非运行异常可捕获和抛出 构造方法 构造方法一定要与定义为public的类同名 构造方法没有返回值 构造方法也是类的方法，可以在创建对象时为成员变量赋值 构造方法可以进行重载，但是参数列表必须不相同，不以返回值和访问级别进行区分 非静态方法只能通过实例对象来调用，不能直接通过类名调用。静态方法（static）才能通过类名直接调用 静态内部类不可以直接访问外围类的非静态数据，而非静态内部类可以直接访问外围类的数据，包括私有数据 java不允许单独的方法，过程或函数存在,需要隶属于某一类中 大多数 JVM 将内存区域划分为 Method Area（Non-Heap）（方法区） ,Heap（堆） , Program Counter Register（程序计数器） , VM Stack（虚拟机栈，也有翻译成JAVA 方法栈的）,Native Method Stack （ 本地方法栈 ），其中Method Area 和 Heap 是线程共享的 ，VM Stack，Native Method Stack 和Program Counter Register 是非线程共享的。为什么分为 线程共享和非线程共享的呢?请继续往下看。 首先我们熟悉一下一个一般性的 Java 程序的工作过程。一个 Java 源程序文件，会被编译为字节码文件（以 class 为扩展名），每个java程序都需要运行在自己的JVM上，然后告知 JVM 程序的运行入口，再被 JVM 通过字节码解释器加载运行。那么程序开始运行后，都是如何涉及到各内存区域的呢？ 概括地说来，JVM初始运行的时候都会分配好 Method Area（方法区） 和Heap（堆） ，而JVM 每遇到一个线程，就为其分配一个 Program Counter Register（程序计数器） , VM Stack（虚拟机栈）和Native Method Stack （本地方法栈）， 当线程终止时，三者（虚拟机栈，本地方法栈和程序计数器）所占用的内存空间也会被释放掉。这也是为什么我把内存区域分为线程共享和非线程共享的原因，非线程共享的那三个区域的生命周期与所属线程相同，而线程共享的区域与JAVA程序运行的生命周期相同，所以这也是系统垃圾回收的场所只发生在线程共享的区域（实际上对大部分虚拟机来说知发生在Heap上）的原因 Java中的volatile关键字的功能 1，可见性 可见性指的是在一个线程中对该变量的修改会马上由工作内存（Work Memory）写回主内存（Main Memory），所以会马上反应在其它线程的读取操作中。顺便一提，工作内存和主内存可以近似理解为实际电脑中的高速缓存和主存，工作内存是线程独享的，主存是线程共享的。 2，禁止指令重排序优化 禁止指令重排序优化。大家知道我们写的代码（尤其是多线程代码），由于编译器优化，在实际执行的时候可能与我们编写的顺序不同。编译器只保证程序执行结果与源代码相同，却不保证实际指令的顺序与源代码相同。这在单线程看起来没什么问题，然而一旦引入多线程，这种乱序就可能导致严重问题。volatile关键字就可以从语义上解决这个问题 出于运行速率的考虑，java编译器会把经常经常访问的变量放到缓存（严格讲应该是工作内存）中，读取变量则从缓存中读。但是在多线程编程中,内存中的值和缓存中的值可能会出现不一致。volatile用于限定变量只能从内存中读取，保证对所有线程而言，值都是一致的。但是volatile不能保证原子性，也就不能保证线程安全 final声明的类不能被继承 forward和redirect是最常问的两个问题 forward，服务器获取跳转页面内容传给用户，用户地址栏不变 redirect，是服务器向用户发送转向的地址，redirect后地址栏变成新的地址 1，新生代：（1）所有对象创建在新生代的Eden区，当Eden区满后触发新生代的Minor GC，将Eden区和非空闲Survivor区存活的对象复制到另外一个空闲的Survivor区中。（2）保证一个Survivor区是空的，新生代Minor GC就是在两个Survivor区之间相互复制存活对象，直到Survivor区满为止。 2，老年代：当Survivor区也满了之后就通过Minor GC将对象复制到老年代。老年代也满了的话，就将触发Full GC，针对整个堆（包括新生代、老年代、持久代）进行垃圾回收。3，持久代：持久代如果满了，将触发Full GC4.System.gc() public &gt; protected &gt; 同包（default） &gt; private structs基于MVC模式 静态初始化块&gt;初始化块&gt;构造方法&gt;普通方法 静态优先，父类优先 %和优先级相同，顺序执行，10%3=1 12=2 count是静态变量，被所有对象共享 ConcurrentHashMap使用segment来分段和管理锁，segment继承自ReentrantLock，因此ConcurrentHashMap使用ReentrantLock来保证线程安全 Arrays.asList() 将一个数组转化为一个List对象，这个方法会返回一个ArrayList类型的对象， 这个ArrayList类并非java.util.ArrayList类，而是Arrays类的静态内部类！用这个对象对列表进行添加删除更新操作，就会报UnsupportedOperationException异常 先出现字符串，后面的内容自动强制转换为string进行拼接 先出现数字，则进行加减运算 先算括号里面，数字 byte能表示的范围[-128,127] ThreadLocal的类 ThreadLocal并没有继承自Thread，也没有实现Runnable接口 ThreadLocal是采用哈希表的方式来为每个线程都提供一个变量的副本 ThreadLocal保证各个线程间数据安全，每个线程的数据是数据的独立不会被另外线程访问和破坏 round方法，它表示“四舍五入”Math.round(11.5)=12,Math.round(-11.5)=-11” 后台线程：指为其他线程提供服务的线程，也称为守护线程。JVM的垃圾回收线程就是一个后台线程。 前台线程：是指接受后台线程服务的线程 “编译看左边，运行看右边”。也就是编译时候，会看左边引用类型是否能正确编译通过，运行的时候是调用右边的对象的方法 类变量在不设置初始值时，会进行默认值赋值，而局部方法中声明的变量则必须进行初始化，他不会进行默认值赋值 值传递和引用传递： 值传递：方法调用时，实际参数把它的值传递给对应的形式参数，形式参数只是用实际参数的值初始化自己的存储单元内容，是两个不同的存储单元，所以方法执行中形式参数值的改变不影响实际参数的值 引用传递：也称为传地址。方法调用时，实际参数是对象(或数组)，这时实际参数与形式参数指向同一个地址，在方法执行中，对形式参数的操作实际上就是对实际参数的操作，这个结果在方法结束后被保留了下来，所以方法执行中形式参数的改变将会影响实际参数 抽象类总结 区别1：抽象类体现继承关系，一个类只能単继承。接口体现实现关系，一个类可以多实现 区别2：抽象类中可以定义非抽象方法和抽象方法，子类继承后可以直接使用非抽象方法。接口的方法都是抽象的，必须由子类去实现。接口中的成员都有固定的修饰符 区别3：抽象类有构造方法，用于给子类对象初始化。而接口没有构造方法 特点1：抽象类不可以实例化，即不能用new创建对象。抽象类必须由其子类覆盖了所有的抽象方法后， 该子类才可以实例化，否则，这个子类也是抽象类 特点2：抽象类abstract关键字不能和哪些关键字共存: final 因为final修饰的方法不能被继承。 static因为类.方法（），此方法没有方法体，没有意义。 private 因为抽象方法是要被子类覆盖的，加上private子类就不知道这个方法了。 特点3：接口中声明变量必须是final、public 、static的，接口中定义的方法都是abstract、 public的。接口里的数据成员必须初始化，且全是常量，不是变量。 特点4：接口是抽象类的 *变体（* 你没看错 *），* 接口也可以通过关键字extends来继承其他接口。格式如下所示： class 类名称 implements 接口A，接口B{ //接口的实现} interface 子接口名称 extends 父接口1，父接口2，...{} 线程调度分为协同式调度和抢占式调度，Java使用的是抢占式调度，也就是每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定（协同式调度）。这就是平台独立的原因 自动装箱(自动拆装箱JDK需在1.5上） 基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true 两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述 两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true 基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F09%2F14%2FSpringmvc%2F</url>
    <content type="text"><![CDATA[##01框架原理和入门配置 1.什么是SpringMVC springmvc是spring框架的一个模块，springmvc和spring无需通过中间整合层进行整合。（struts2与Spring整合的时候需要借助单独的jar包） springmvc是一个基于mvc的web框架。 2.MVC在b/s系统下的应用 ###3.SpringMVC框架原理 步骤 发起请求到前端控制器 (DispatcherServlet) 前端控制器请求处理器映射器 (HandlerMapping) 查找 Handler (可根据 xml 配置、注解进行查找) 处理器映射器 (HandlerMapping) 向前端控制器返回 Handler 前端控制器调用处理器适配器 (HandlerAdapter) 执行 Handler 处理器适配器 (HandlerAdapter) 去执行 Handler Handler 执行完，给适配器返回 ModelAndView (SpringMVC 框架的一个底层对象) 处理器适配器 (HandlerAdapter) 向前端控制器返回 ModelAndView 前端控制器 (DispatcherServlet) 请求视图解析器 (ViewResolver) 进行视图解析，根据逻辑视图名解析成真正的视图 (jsp) 视图解析器 (ViewResolver) 向前端控制器 (DispatcherServlet) 返回 View 前端控制器进行视图渲染，即将模型数据 (在 ModelAndView 对象中)填充到 request 域 前端控制器向用户响应结果 组件及其作用 前端控制器 (DispatcherServlet) 接收请求，响应结果，相当于转发器，中央处理器。 有了DispatcherServlet减少了其他组件之间的耦合度 处理器映射器 (HandlerMapping) 作用：根据请求的 url 查找 Handler 处理器 (Handler) 注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler 处理器适配器 (HandlerAdapter) 作用：按照特定规则（HandlerAdapter要求的规则）执行Handler。 视图解析器 (ViewResolver) 作用：进行视图解析，根据逻辑视图解析成真正的视图 (View) 视图 (View) View 是一个接口实现类支持不同的 View 类型（jsp,pdf等等） 4.SpringMVC入门程序 一个展示商品列表的小页面 2.mybatis1.mybatis之SqlSession SqlSession的作用 向SQL语句传入参数 执行SQL语句 获取执行后的结果 事务控制 如何得到SQLSession 通过配置文件获取数据库连接相关信息 通过配置文件信息构建SqlSessionFactory 通过SqlSessionFactory打开数据库对话]]></content>
  </entry>
  <entry>
    <title><![CDATA[玩转数据结构]]></title>
    <url>%2F2018%2F09%2F14%2F%E7%8E%A9%E8%BD%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[1.数组1.数组的定义数组是一种常见的数据类型，用于存储多个相同数据类型的集合。 2.数组的创建方式123456//数组的创建方式1int[] a = &#123;1,2,3&#125;;//方式2int[] b = new int[]&#123;1,2,3&#125;;//方式3int[] c = new int[3]; 3.向数组中添加，查询搜索和删除元素4.动态数组 数组动态伸缩 数组扩容，缩容 5.时间复杂度 算法的时间复杂度是一个函数，它定性描述了该算法的运行时间 均摊复杂度 复杂度震荡 2.栈和队列1.栈 栈（stack）又名堆栈，它是一种线性表 ，先进后出，从栈顶添加元素，栈顶取出 ###2.栈的应用 撤销操作，就相当于一个先进后出 程序调用的系统栈 括号匹配，用栈解决问题 3.队列 队列也是一种线性结构，先进先出。 数组队列 循环队列 front表示队首的元素 tail表示队尾下一个元素的位置 3.链表 链表是一种最简单的，真正的动态数据结构 优点 真正的动态，不需要处理固定容量问题 缺点 丧失了随机访问的能力 节点装载元素，节点连接 链表实现栈，链表头做栈顶 链表实现队列，链表头取元素，链表尾部插入元素 4.链表与递归1.递归 递归通常就是把一个原问题转化为一个规模较小的问题 递归调用是有代价的：函数调用+系统栈空间 2.二分搜索树二叉树 二分搜索树是特殊的二叉树 二叉树前序遍历 首先访问根节点 然后访问根节点的左子树 然后访问根节点的右子树 中序遍历 先访问左子树 再访问节点 后访问右子树 中序遍历后是从小到大的排序结果 后序遍历 先访问左子树 再访问右子树 后访问根节点 非递归遍历需要借助栈Stack 3.深度优先遍历（DFS） 前中后序遍历本质都是dfs 4.广度优先遍历（BFS） 也叫层序遍历 5.排序基础1.冒泡排序 基本原理 从第一个数据开始，与第二个数据相比较，如果第二个数据小于第一个数据，则交换两个数据的位置 指针由第一个数据移向第二个数据，第二个数据与第三个数据相比较，如果第三个数据小于第二个数据，则交换两个数据的位置 依此类推，完成第一轮排序。第一轮排序结束后，最大的元素被移到了最右面 依照上面的过程进行第二轮排序，将第二大的排在倒数第二的位置 重复上述过程，没排完一轮，比较次数就减少一次 共进行n-1轮排序 编码思路： 需要两层循环，第一层循环i表示排序的轮数，第二层循环j表示比较的次数 冒泡排序算法总结 N个元素需要排序N-1轮 第i轮需要比较N-i次 N个元素比较，需要比较n(n-1)/2次 冒泡排序算法复杂度较高O(n*n) 2.选择排序SelectionSort 选择排序是对冒泡排序的改进，比较次数和冒泡排序相同，但是交换次数要小于冒泡排序，时间复杂度为O(n*n) 基本原理： 从第一个元素开始，分别与后面的元素向比较，找到最小的元素与第一个元素交换位置 从第二个元素开始，分别与后面的元素相比较，找到剩余元素中最小的元素，与第二个元素交换 重复上述步骤，直到所有的元素都排成由小到大为止 编码思路： 需要两次循环，第一层循环i表示每轮指针指向的位置，将最小值min初始化为第i个元素，第二层循环从j=i+1开始，分别与min比较，如果小于min，则更新min的值，内层循环结束后；交换min元素和第i个元素的位置。以此类推进行下一轮循环，直到i=length时停止循环。当i=length时，说明小的元素已经全部移到了左面，因此无需进行内层循环了 选择排序总结 N个元素需要排序N-1轮 第i轮需要比较N-i次 N个元素排序，需要比较n（n-1）/2次 选择排序的算法复杂度仍为O（n*n） 相比于冒泡排序，选择排序的交换次数大大减少，因此速度要快于冒泡排序 3.插入排序 插入排序是简单排序中最快的排序算法，虽然时间复杂度仍然为O(n*n)，但是却比冒泡排序和选择排序快很多 基本原理： 将指针指向某个元素，假设该元素左侧的元素全部有序，将该元素抽取出来，然后按照从右往左的顺序分别与其左边的元素比较，遇到比其大的元素便将元素右移，直到找到比该元素小的元素或者找到最左面发现其左侧的元素都比它大，停止 此时会出现一个空位，将该元素放入到空位中，此时该元素左侧的元素都比它小，右侧的元素都比它大 指针向后移动一位，重复上述过程。每操作一轮，左侧有序元素都增加一个，右侧无序元素都减少一个 编码分析： 需要两层循环，第一层循环index表示上述例子中的指针，即遍历从坐标为1开始的每一个元素；第二层循环从leftindex=index-1开始，leftindex–向左遍历，将每一个元素与i处的元素比较，直到j处的元素小于i出的元素或者leftindex&lt;0；遍历从i到j的每一个元素使其右移，最后将index处的元素放到leftindex处的空位处 插入排序总结： 插入排序的速度约比冒泡排序快一倍（比较次数少一倍），比选择排序还要快一些，对于基本有序的数据，插入排序的速度会很快，是简单排序中效率最高的排序算法 4.希尔排序 希尔排序属于插入类排序,是将整个有序序列分割成若干小的子序列分别进行插入排序 基本原理： 希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快） 步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作（且步长要小于数组长度）。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序 5.归并排序 O(nlogN) 归并排序 (merge sort) 是一类与插入排序、交换排序、选择排序不同的另一种排序方法。归并的含义是将两个或两个以上的有序表合并成一个新的有序表, 将两个或者两个以上的有序表合并成一个新的有序表，即把待排序的序列分成若干个子序列,每个序列是有序的，然后把有序序列合并成整体有序序列 是一种稳定排序方式 6.快速排序 算法思路： 设置两个变量i、j，排序开始的时候：i=0，j=N-1 以第一个数组元素作为关键数据，赋值给key，即key=A[0] 从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换 从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换 重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束） 7.堆排序 了解堆 二叉堆是一颗完全二叉树（最大堆） 堆中的某节点的值总是小于其父节点的值（大顶堆） ##8.树，森林，二叉树的转换 将树或者森林转换成对应的二叉树方法： 在所有的兄的节点之间添加一条连线，如果是森林，则在其所有树的树根之间同样添加一条连线。 对于树，森林的每个节点，除保留其到第一个子女的连线外，撤销其到其他子女的连线 将以上得到的树按顺时针旋转45° 得到对应的二叉树 二叉树到森林的转换 上述过程的逆过程 3-&gt;2-&gt;1. 9.线性表的检索（查找）1.顺序检索 从线性表的头扫描到尾部 2.二分法检索（折半查找nlog2n） 条件：只适用于顺序存储结构 找到中间节点，判断大于还是小于，取前半段还是后半段，再取半段中的中间节点，判断，重复进行，直到找到为止。 3.分块检索 结合顺序查找和二分查找 基本思想： 将线性表分为若干块，在每一块中，结点的存放不一定有序，但块与块之间必须是分块有序的 4.二叉排序树5.丰满树和平衡二叉排序树（AVL树) 丰满树： 满足任意两个非孩子节点的高度之差的绝对值小于等于1 平衡二叉树具有的性质： 它的左子树和右子树都是平衡二叉树，且左子树和右子树高度之差的绝对值不超过1（可以是空树） 平衡因子即平衡二叉树的左右子树高度差，可取-1，0，1 左子树深度减去右子树的为平衡因子 平衡二叉树的高度节点数量之间的关系也是O(logn) 6.AVL树的插入算法描述 目的：维护平衡 若AVL树t为空树，则插入一个数据元素为x的新节点作为t的根结点，树的深度为1. 若x和AVL树的根节点关键字相同，则不插入。 若x的关键字小于AVL树得根结点，分以下三种情况处理： 若AVL树的根结点的平衡因子为-1，则将根结点的平衡因子调节为0，树的深度不表。 若AVL树的根节点的平衡因子为0，则将根结点的平衡因子调节为1，树的深度加一 若AVL树的平衡因子为1，则当改左子树根结点为1时，需要进行LL平衡旋转，当该树的左子树的根结点平衡因子为-1时需要LR平衡旋转。 若x关键字大于根节点，则将x插入到该树的右子树，并且当插入后的右子树深度增加1时，参考（3）按情况处理. 7.B-树和B+树 B-树：一种适合于外查找的树 一颗m阶B树是一棵m路平衡搜索树，或者是空树，满足以下性质。 根结点至少有两个子女 每个非根节点所包含的关键字个数 n 满足：[m/2]-1&lt;=n&lt;=m-1 除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故内部子树个数 k 满足：[m/2]&lt;= k &lt;= m 所有的叶子结点都位于同一层 B+树：m阶B+树结构定义 树中每个结点至多有m棵子树 除根结点之外的每个结点至少有[m/2]棵子树 若根结点不是叶子节点且非空，则至少有2棵子树 所有的叶子结点包含全部关键字及指向相应记录的指针，而且叶子结点按关键字大小顺序链接（可以把每个叶子节点看成一个基本索引块，它的指针不在指向另一级索引，而是直接指向数据文件中的记录） B树和B+树区别： 为什么是B+树而不是B树呢，因为它内节点不存储data，这样一个节点就可以存储更多的key B+树上增加了顺序访问指针，也就是每个叶子节点增加一个指向相邻叶子节点的指针，这样一棵树成了数据库系统实现索引的首选数据结构 10.树的总结一、二叉查找树（1）二叉树简介： 二叉查找树也称为有序二叉查找树，满足二叉查找树的一般性质，是指一棵空树具有如下性质： 1、任意节点左子树不为空,则左子树的值均小于根节点的值； 2、任意节点右子树不为空,则右子树的值均大于于根节点的值； 3、任意节点的左右子树也分别是二叉查找树； 4、没有键值相等的节点；上图为一个普通的二叉查找树，按照中序遍历的方式可以从小到大的顺序排序输出：2、3、5、6、7、8。 对上述二叉树进行查找，如查键值为5的记录，先找到根，其键值是6，6大于5，因此查找6的左子树，找到3；而5大于3，再找其右子树；一共找了3次。如果按2、3、5、6、7、8的顺序来找同样需求3次。用同样的方法在查找键值为8的这个记录，这次用了3次查找，而顺序查找需要6次。计算平均查找次数得：顺序查找的平均查找次数为（1+2+3+4+5+6）/ 6 = 3.3次，二叉查找树的平均查找次数为（3+3+3+2+2+1）/6=2.3次。二叉查找树的平均查找速度比顺序查找来得更快。 （2）局限性及应用 一个二叉查找树是由n个节点随机构成，所以，对于某些情况，二叉查找树会退化成一个有n个节点的线性链。如下图：大家看上图，如果我们的根节点选择是最小或者最大的数，那么二叉查找树就完全退化成了线性结构。上图中的平均查找次数为（1+2+3+4+5+5）/6=3.16次，和顺序查找差不多。显然这个二叉树的查询效率就很低，因此若想最大性能的构造一个二叉查找树，需要这个二叉树是平衡的（这里的平衡从一个显著的特点可以看出这一棵树的高度比上一个输的高度要大，在相同节点的情况下也就是不平衡），从而引出了一个新的定义-平衡二叉树AVL。 ###二、AVL树 （1）简介 AVL树是带有平衡条件的二叉查找树，一般是用平衡因子差值判断是否平衡并通过旋转来实现平衡，左右子树树高不超过1，和红黑树相比，它是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差不超过1）。不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而旋转是非常耗时的，由此我们可以知道AVL树适合用于插入删除次数比较少，但查找多的情况。从上面是一个普通的平衡二叉树，这张图我们可以看出，任意节点的左右子树的平衡因子差值都不会大于1。 （2）局限性 由于维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果应用场景中对插入删除不频繁，只是对查找要求较高，那么AVL还是较优于红黑树。 （3）应用 1、Windows NT内核中广泛存在； ###三、红黑树 （1）简介 一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是red或black。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍。它是一种弱平衡二叉树(由于是若平衡，可以推出，相同的节点情况下，AVL树的高度低于红黑树)，相对于要求严格的AVL树来说，它的旋转次数变少，所以对于搜索、插入、删除操作多的情况下，我们就用红黑树。 （2）性质 1、每个节点非红即黑；2、根节点是黑的；3、每个叶节点(叶节点即树尾端NULL指针或NULL节点)都是黑的；4、如果一个节点是红的,那么它的两儿子都是黑的；5、对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点；6、每条路径都包含相同的黑节点； （3）应用 1、广泛用于C++的STL中，Map和Set都是用红黑树实现的；2、著名的Linux进程调度Completely Fair Scheduler，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一颗红黑树上，每个虚拟地址区域都对应红黑树的一个节点，左指针指向相邻的地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间；3、IO多路复用epoll的实现采用红黑树组织管理sockfd，以支持快速的增删改查；4、Nginx中用红黑树管理timer，因为红黑树是有序的，可以很快的得到距离当前最小的定时器；5、Java中TreeMap的实现； ###四、B/B+树 说了上述的三种树：二叉查找树、AVL和红黑树，似乎我们还没有摸到MySQL为什么要使用B+树作为索引的实现，不要急，接下来我们就先探讨一下什么是B树。 （1）简介 我们在MySQL中的数据一般是放在磁盘中的，读取数据的时候肯定会有访问磁盘的操作，磁盘中有两个机械运动的部分，分别是盘片旋转和磁臂移动。盘片旋转就是我们市面上所提到的多少转每分钟，而磁盘移动则是在盘片旋转到指定位置以后，移动磁臂后开始进行数据的读写。那么这就存在一个定位到磁盘中的块的过程，而定位是磁盘的存取中花费时间比较大的一块，毕竟机械运动花费的时候要远远大于电子运动的时间。当大规模数据存储到磁盘中的时候，显然定位是一个非常花费时间的过程，但是我们可以通过B树进行优化，提高磁盘读取时定位的效率。 为什么B类树可以进行优化呢？我们可以根据B类树的特点，构造一个多阶的B类树，然后在尽量多的在结点上存储相关的信息，保证层数尽量的少，以便后面我们可以更快的找到信息，磁盘的I/O操作也少一些，而且B类树是平衡树，每个结点到叶子结点的高度都是相同，这也保证了每个查询是稳定的。 总的来说，B/B+树是为了磁盘或其它存储设备而设计的一种平衡多路查找树(相对于二叉，B树每个内节点有多个分支)，与红黑树相比，在相同的的节点的情况下，一颗B/B+树的高度远远小于红黑树的高度(在下面B/B+树的性能分析中会提到)。B/B+树上操作的时间通常由存取磁盘的时间和CPU计算时间这两部分构成，而CPU的速度非常快，所以B树的操作效率取决于访问磁盘的次数，关键字总数相同的情况下B树的高度越小，磁盘I/O所花的时间越少。 注意B-树就是B树，-只是一个符号。 （2）B树的性质 1、定义任意非叶子结点最多只有M个儿子，且M&gt;2；2、根结点的儿子数为[2, M]；3、除根结点以外的非叶子结点的儿子数为[M/2, M]；4、每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）5、非叶子结点的关键字个数=指向儿子的指针个数-1；6、非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；7、非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；8、所有叶子结点位于同一层；这里只是一个简单的B树，在实际中B树节点中关键字很多的，上面的图中比如35节点，35代表一个key(索引)，而小黑块代表的是这个key所指向的内容在内存中实际的存储位置，是一个指针。 ###五、B+树 （1）简介 B+树是应文件系统所需而产生的一种B树的变形树（文件的目录一级一级索引，只有最底层的叶子节点（文件）保存数据）非叶子节点只保存索引，不保存实际的数据，数据都保存在叶子节点中，这不就是文件系统文件的查找吗? 我们就举个文件查找的例子：有3个文件夹a、b、c， a包含b，b包含c，一个文件yang.c，a、b、c就是索引（存储在非叶子节点）， a、b、c只是要找到的yang.c的key，而实际的数据yang.c存储在叶子节点上。 所有的非叶子节点都可以看成索引部分！ （2）B+树的性质(下面提到的都是和B树不相同的性质) 1、非叶子节点的子树指针与关键字个数相同；2、非叶子节点的子树指针p[i],指向关键字值属于[k[i],k[i+1]]的子树.(B树是开区间,也就是说B树不允许关键字重复,B+树允许重复)；3、为所有叶子节点增加一个链指针；4、所有关键字都在叶子节点出现(稠密索引). (且链表中的关键字恰好是有序的)；5、非叶子节点相当于是叶子节点的索引(稀疏索引),叶子节点相当于是存储(关键字)数据的数据层；6、更适合于文件系统； 非叶子节点（比如5，28，65）只是一个key（索引），实际的数据存在叶子节点上（5，8，9）才是真正的数据或指向真实数据的指针。 （3）应用 1、B和B+树主要用在文件系统以及数据库做索引，比如MySQL； ###六、B/B+树性能分析 n个节点的平衡二叉树的高度为H(即logn)，而n个节点的B/B+树的高度为logt((n+1)/2)+1；若要作为内存中的查找表，B树却不一定比平衡二叉树好，尤其当m较大时更是如此。因为查找操作CPU的时间在B-树上是O(mlogtn)=O(lgn(m/lgt))，而m/lgt&gt;1；所以m较大时O(mlogtn)比平衡二叉树的操作时间大得多。因此在内存中使用B树必须取较小的m。（通常取最小值m=3，此时B-树中每个内部结点可以有2或3个孩子，这种3阶的B-树称为2-3树）。 ###七、为什么说B+树比B树更适合数据库索引？ 1、 B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。 2、B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 3、由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。 PS：我在知乎上看到有人是这样说的,我感觉说的也挺有道理的： 他们认为数据库索引采用B+树的主要原因是：B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。 今天看了几篇文章，自己总结一下。 数据库使用B+树肯定是为了提升查找效率。 但是具体如何提升查找效率呢？ 查找数据，最简单的方式是顺序查找。但是对于几十万上百万，甚至上亿的数据库查询就很慢了。 所以要对查找的方式进行优化，熟悉的二分查找，二叉树可以把速度提升到O(log(n,2))，查询的瓶颈在于树的深度，最坏的情况要查找到二叉树的最深层，由于，每查找深一层，就要访问更深一层的索引文件。在多达数G的索引文件中，这将是很大的开销。所以，尽量把数据结构设计的更为‘矮胖’一点就可以减少访问的层数。在众多的解决方案中，B-/B+树很好的适合。B-树定义具体可以查阅，简而言之就是中间节点可以多余两个子节点，而且中间的元素可以是一个域。相比B-树，B+树的父节点也必须存在于子节点中，是其中最大或者最小元素，B+树的节点只存储索引key值，具体信息的地址存在于叶子节点的地址中。这就使以页为单位的索引中可以存放更多的节点。减少更多的I/O支出。因此，B+树成为了数据库比较优秀的数据结构，MySQL中MyIsAM和InnoDB都是采用的B+树结构。不同的是前者是非聚集索引，后者主键是聚集索引，所谓聚集索引是物理地址连续存放的索引，在取区间的时候，查找速度非常快，但同样的，插入的速度也会受到影响而降低。聚集索引的物理位置使用链表来进行存储。 11.图1.图的基本概念 顶点 无向边，无向图 有向边，有向图 权值 网：带权值的图 子图 度，出度，入度 连通图：图中任意两个顶点都是连通的。 2.图的存储结构 邻接矩阵：用两个数组，一个数组保存顶点集，一个数组保存边集。 3.图的遍历 深度优先遍历（DFS）：从图中某个顶点v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到。 广度优先遍历（BFS）：假设从C0出发，接着访问C0的邻接点C1和C2，依次访问与C1邻接的未曾访问的C3和C4，然后访问与C2邻接未曾访问的C5，直到全部访问。 4.最小生成树 基本概念 普里姆算法（prim） 克鲁斯卡尔算法（kruskal） 5.最短路径 （Dijkstra）：把图中的顶点集合V分成两组，第一组为已求出最短路径的顶点集合S（初始时S中只有源节点，以后每求得一条最短路径，就将它对应的顶点加入到集合S中，直到全部顶点都加入到S中）；第二组是未确定最短路径的顶点集合U。 算法步骤： （1）初始化时，S只含有源节点； （2）从U中选取一个距离v最小的顶点k加入S中（该选定的距离就是v到k的最短路径长度）； （3）以k为新考虑的中间点，修改U中各顶点的距离；若从源节点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值是顶点k的距离加上k到u的距离； （4）重复步骤（2）和（3），直到终点在S中]]></content>
  </entry>
  <entry>
    <title><![CDATA[spring]]></title>
    <url>%2F2018%2F09%2F14%2FSpring%2F</url>
    <content type="text"><![CDATA[Spring 分层： web层： struts，springmvc service层：spring dao层：hibernate，mybatis，jdbcTemplate，spring-data ##1.什么是Spring spring是一个基于IOC和APO的结构的J2EE系统的轻量级框架，Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情 ，它的核心主要是ioc和aop。 IOC（Inversion Of Control）反转控制是spring的基础，简单地说就是创造对象由以前的程序员自己new构造方法来调用，变成了交由spring创建对象。 DI依赖注入（Dependency Inject），简单地说就是拿到对象的属性，已经被注入好相关值了，直接使用即可。 ##2.IOC思想： ​ 其思想是反转资源获取的方向，传统的资源查找方式要求组件向容器发起请求查找资源，作为应答，容器适时的返回资源，而应用了IOC后，则是则是容器主动的将资源推送给它所在的管理组件，组件所要做的仅是选择一种合适的方式来接受资源，这种行为也被称为查找的被动形式。 IOC（Inversion Of Control）反转控制是spring的基础，简单地说就是创造对象由以前的程序员自己new构造方法来调用，变成了交由spring创建对象。 Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下： ●谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。 ●为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。 AOP（Aspect Oriented Programming ）面向切面，AOP主要实现的目的是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果 ，通俗点讲就是提供一个为一个业务实现提供切面注入的机制，通过这种方式，在业务运行中将定义好的切面通过切入点绑定到业务中，以实现将一些特殊的逻辑绑定到此业务中 。 核心容器：bean，core，context，expression ##2.Spring的优点 方便解耦，简化开发（高内聚低耦合) Spring就是一个大工厂（容器），可以将所有的对象创建和依赖关系维护，交给Spring管理 spring工厂是用于生成bean 。 AOP编程的支持 Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能 声明式事务的支持 只需要通过配置就可以完成对事务的管理，而无需手动编程 方便程序的测试 Spring对Junit4支持，可以通过注解方便的测试Spring程序 方便集成各种优秀框架 Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz等）的直接支持 降低JavaEE API的使用难度 Spring 对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低 ##3.配置Bean 配置形式：基于XML文件的方式，基于注解的方式 Bean的配置方式：通过反射，通过工厂方法，FactoryBean IOC容器 1.Spring容器 在SpringIOC容器读取Bean配置创建Bean实例之前必须对他进行实例化，只有容器实例化后，才可以从IOC容器里获取Bean实例并使用。 Spring提供两种类型的IOC容器实现 BeanFactory：IOC容器的基本实现 ApplicationContext：提供更多高级的特性，是BeanFactory的子接口 BeanFactory是Spring框架的基础设施，面向spring本身，ApplicationContext面向Spring框架的开发者，几乎所有的应用场合直接都用ApplicationContext而非BeanFactory。 无论什么方式，配置文件相同 12345678//1.创建Spring的IOC容器对象//ApplicationContext 代表容器//ClassPathXmlApplicationContext 是 ApplicationContext 接口的实现类：从类路径加载配置文件ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");//2.从IOC容器中获取bean实例//利用id定位到IOC容器中的BeanHelloWorld helloWorld = (HelloWorld) ctx.getBean("helloworld"); 2.依赖注入的方式###1，属性注入 属性注入即通过setter方法注入Bean的属性值或依赖的对象 属性注入使用property元素，使用name属性指定Bean的属性名称，value属性指定属性值 属性注入是最常用的注入方式 123&lt;bean id="helloworld" class="com.HelloWorld"&gt; &lt;property name="name2" value="Spring"&gt;&lt;/property&gt;&lt;/bean&gt; ###2，构造方法注入 通过构造方法注入Bean的属性值或依赖的对象，它保证了Bean实例在实例化后就可以使用。 构造器注入《construct-arg》元素声明属性 ###3，工厂方法注入 4，Bean之间的引用 在Bean配置文件中，通过&lt; ref &gt;元素或ref属性为Bean的属性指定对Bean的引用 内部Bean 在Bean引用时在自己内部构建一个Bean 不能被外部Bean引用]]></content>
  </entry>
  <entry>
    <title><![CDATA[利用hexo+github搭建免费博客]]></title>
    <url>%2F2018%2F09%2F12%2F%E5%88%A9%E7%94%A8hexo%2Bgithub%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一、准备工作： 注册一个github账号 ：支持高亮代码块、LaTeX 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手； 安装node.js ：下载链接https://pan.baidu.com/s/1xTBWJ-FFqe6_UfpYezuBtA 安装git ：下载链接https://pan.baidu.com/s/1FdgU2wjgF4RXQc5JRXrxbw 安装node.js和git ：只需要按默认next就ok了。 node.js环境配置：参考链接中的步骤https://www.jianshu.com/p/03a76b2e7e00 二、开始： 创建blog文件夹、并安装hexo、创建github仓库：在你的某个盘符下根目录创建一个blog空文件夹，操作步骤参考下面链接中的步骤3和4https://www.cnblogs.com/fengxiongZz/p/7707219.html 配置SSH key：参考下面链接中的步骤3https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html和参考下面链接中的步骤5https://www.cnblogs.com/fengxiongZz/p/7707219.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[helloJava]]></title>
    <url>%2F2018%2F09%2F12%2Fjava%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.继承 java类中只有单继承 Object类是所有类的父类，默认继承，Object类中的方法适合所有子类 1.参数 定义方法时的参数称为形参，调用方法时的参数称为实参 2.重载 判断方法重载的依据： 必须是在同一个类中 方法名相同 方法参数的个数，顺序或类型不同 与方法的修饰符或返回值没有关系， 覆盖和重载：覆盖只发生在父类和子类之间，而重载可以发生在同一个类 重写（覆盖）：子类可以继承父类的方法，但是子类对父类的方法不满意，可以重写父类继承的方法，当调用方法时会优先调用子类的方法 Java 会根据参数的个数和类型来判断应该调用哪个重载方法，参数完全匹配的方法将被执行 3.局部变量和成员变量 局部变量是定义在方法中，作用域仅在方法中，Java不会给局部变量一个初始值 成员变量在类中，作用域在整个类，java会给成员变量一个初始值 4.static关键字 静态变量可以直接使用类名直接访问，非静态变量则需要创建一个类的对象来调用该变量静态的方法 静态初始化块&gt;初始化块&gt;构造方法&gt;普通方法 123456789101112131415161718192021222324252627public class Statickuai &#123; String name; String sex; static int age; //构造方法 public Statickuai()&#123; System.out.println("通过构造方法初始化name"); name = "tom"; &#125; //初始化块 &#123; System.out.println("通过初始化块初始化sex"); sex = "男"; &#125; //静态初始化块 static &#123; System.out.println("通过静态初始化快初始化age"); age = 20; &#125; public void show()&#123; System.out.println(name+sex+age); &#125; public static void main(String[] args) &#123; Statickuai hi=new Statickuai(); hi.show(); &#125;&#125; 5.封装 修改属性的可见性：设为private .创建getter/setter方法：用于属性的读写 .在getter/setter方法中加入属性控制语句：对属性值的合法性进行判断 优点：1，只能通过规定的方法访问数据 2，隐藏类的实例细节，方便修改 6.内部类 成员内部类 静态内部类 匿名内部类 方法内部类 7.final关键字 修饰类则不允许被继承 修饰方法则不允许被重写 修饰属性则该类的属性不会进行隐式的初始化（自己赋值0.0）或在构造方法中赋值 修饰变量则就是常量，必须初始化且不可更改 8.super关键字 子类的构造的过程必须调用其父类的构造方法 如果子类的构造方法中没有显示调用父类得构造方法，系统默认调用父类无参的构造方法 如果显示的调用构造方法，必须在子类的构造方法的第一行 如果子类构造方法中既没有显示调用父类的构造方法，而又没有无参的构造方法，则出错 调用父类属性 super.age 调用父类方法 super.eat() 9.equals和== equals： 比较的是对象的引用是否指向同一块内存地址 重写equals方法来达到比较两个对象的属性值和方法是否相同 10.多态11.抽象类 抽象类前使用abstract关键字修饰abstract class 抽象方法没有方法体以;结束 抽象类不能被实例化 限制实现某些子类必须实现的某些方法，不关注具体实现的细节 抽象类关注它的存在性，是什么 12.接口 若要实现一个接口为普通类则必须实现接口的所有抽象方法 接口下的方法只能是抽象方法 接口类的使用必须由接口的实现类来实现 接口 对象名=new 接口的实现类 13.异常 运行时异常 非运行时异常 14.String和StringBuilder String 对象存储字符串的效率比 StringBuilder 高 在需要频繁对字符串进行修改操作时使用 StringBuilder 的效率比 String 要高 2.容器，集合基本概念 Collection接口：定义了存取一组对象的方法，其子接口Set和List分别定义了存储方式。 List：有序可重复 Set：无序不可重复 Map接口定义了存储 ” 键（key）——值（Value）“映射对的方法 3.多线程 什么是线程，什么是进程 进程就是一个启动的程序，而线程就是程序里执行操作的控制单元 线程创建的三种方式 继承Thread类 实现runnable接口 匿名内部类 实现方式和继承方式有什么区别： 实现方式避免了单继承的局限性 继承Thread:线程代码存放在Thread子类的run方法中 实现Runnable：线程代码存放在接口的子类的run方法中 常见的线程方法 sleep 当前线程暂停 join 加入到当前线程中 setPriority 线程优先级 yield 临时暂停 setDaemon 守护线程 同步（并发） 多线程的同步问题指的是多个线程同时修改一个数据的时候，可能导致的问题 使用synchronized解决同步问题，synchronized表示当前线程，独占对象 someObject 当前线程独占 了对象someObject，如果有其他线程试图占有对象someObject，就会等待，直到当前线程释放对someObject的占用。 someObject 又叫同步对象，所有的对象，都可以作为同步对象 为了达到同步的效果，必须使用同一个同步对象 关键字synchronized解决办法1.同步代码块：synchronized（对象） { 需要被同步的代码 } 2.synchronized修饰： 如果一个类，其方法都是有synchronized修饰的，那么该类就叫做线程安全的类 死锁 wait()和notify()方法进行线程交互 线程池 Lock接口对象解决同步问题 与 synchronized (someObject) 类似的，lock()方法，表示当前线程占用lock对象，一旦占用，其他线程就不能占用了。 与 synchronized 不同的是，一旦synchronized 块结束，就会自动释放对someObject的占用。 lock却必须调用unlock方法进行手动释放，为了保证释放的执行，往往会把unlock() 放在finally中进行。 总结Lock和synchronized的区别 Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现，Lock是代码层面的实现。 Lock可以选择性的获取锁，如果一段时间获取不到，可以放弃。synchronized不行，会一根筋一直获取下去。 借助Lock的这个特性，就能够规避死锁，synchronized必须通过谨慎和良好的设计，才能减少死锁的发生。 synchronized在发生异常和同步块结束的时候，会自动释放锁。而Lock必须手动释放， 所以如果忘记了释放锁，一样会造成死锁。 4.Hibernate JDBC 数据库的crud操作 预编译Statement 和 Statement一样，PreparedStatement也是用来执行sql语句的 这是JAVA里唯二的基1的地方，另一个是查询语句中的ResultSet也是基1的 Statement 需要进行字符串拼接，可读性和维护性比较差 ，PreparedStatement 使用参数设置，可读性好，不易犯错 PreparedStatement有预编译机制，性能比Statement更快 execute和executeUpdate 相同点：都可以执行增加，删除，修改 不同点： execute可以执行查询语句 然后通过getResultSet，把结果集取出来 executeUpdate不能执行查询语句 execute返回boolean类型，true表示执行的是查询语句，false表示执行的是insert,delete,update等等 executeUpdate返回的是int，表示有多少条数据受到了影响 hibernate实际是对jdbc的一种封装 ORM（object relational mapping）对象关系映射 MVC思想 （model view controller）模型 视图 控制器 实体类对象在Hibernate中有3种状态 瞬时：指的是没有和hibernate发生任何关系，在数据库中也没有对应的记录，一旦JVM结束，这个对象也就消失了 持久：指得是一个对象和hibernate发生联系，有对应的session,并且在数据库中有对应的一条记录 托管：指的是一个对象虽然在数据库中有对应的一条记录，但是它所对应的session已经关闭了 HQL ( hibernate query language ) hibernate专门用于查询数据的语句 使用Criteria查询 与HQL和SQL的区别是Criteria 完全是 面向对象的方式在进行数据查询，将不再看到有sql语句的痕迹 Criteria 还可以很方便的进行进行和获取总数 关系 一对一 共享主键方式：就是限制两个数据表的主键使用相同的值，通过主键形成一对一映射关系 唯一外键方式：就是一个表中的外键和另一个表中的唯一主键对应形成一对一映射关系 多对一 一对多 多对多 事务 Hibernate的任何对数据有改动的操作，都应该被放在事务里面 ，在事务中的多个操作行为，要么都成功，要么都失败 延迟加载 属性的延迟加载: 当使用load的方式来获取对象的时候，只有访问了这个对象的属性，hibernate才会到数据库中进行查询。否则不会访问数据库 比如有的页面只需要显示分类信息，这个时候倘若没有开启延迟加载，那么就会把分类下的产品也查询出来了，增加了不必要的开销 什么是级联 ：简单的说，没有配置级联的时候，删除分类，其对应的产品不会被删除。 但是如果配置了恰当的级联，那么删除分类的时候，其对应的产品都会被删除掉 缓存 Hibernate的一级缓存是在Session上（默认开启），二级缓存是在SessionFactory上 两种获取方式 load方式是延迟加载，只有属性被访问的时候才会调用sql语句 get方式是非延迟加载，无论后面的代码是否会访问到属性，马上执行sql语句 代码比较复制代码 注解 hibernate里常用注解包括，类注解，属性注解，关系注解，其他的注解 5.网络编程 使用Socket进行不同程序间的通信 建立连接 服务端开启端口并监听，时刻等待客户端的连接请求 客户端知道服务端的ip地址和监听端口号，发出请求到服务端 客户端的端口地址是系统分配的，一旦建立连接，服务器会得到一个新的Socket对象，该对象负责与客户端进行通信 6.Struts2 Javaweb三层框架 web层：表示层，主要架构模式为MVC，主要框架有Spring MVC和Struts2 Service层：业务逻辑层，主要框架有Spring Dao层：数据访问层，主要框架有：MyBatis和Hibernate SSH：Struts2 + Spring + Hibernate SSM：Spring MVC + Spring + MyBatis（目前更流行） struts2是基于MVC的Web框架 7.注解 Annotation的作用： 不是程序本身，可以对程序做出解释（这一点和注释没什么区别） 可以被其他程序读取（注解信息处理流程，是注解和注释最大的区别。如果没有注解信息处理流程，则注解毫无意义） Annotation的格式 注解是以 @注释名 在代码中存在的，还可以添加一些参数值例如：@SuppressWarnings（value =”unchecked“) 基本内置注解 @Override @Deprecated @SuppressWarnings Suppress 等等 自定义注解 创建注解类型的时候即不使用class也不使用interface,而是使用@interface public @interface JDBCConfig 元注解 @Target({METHOD,TYPE}) 表示这个注解可以用用在类/接口上，还可以用在方法上 @Retention(RetentionPolicy.RUNTIME) 表示这是一个运行时注解，即运行起来之后，才获取注解中的相关信息，而不像基本注解如@override那种不用运行，在编译时eclipse就可以进行相关工作的编译时注解。 @Inherited 表示这个注解可以被子类继承 注解元素，这些注解元素就用于存放注解信息，在解析的时候获取出来]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
