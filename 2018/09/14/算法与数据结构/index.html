<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.1" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.1">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.4.1',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="1.数组1.数组的定义数组是一种常见的数据类型，用于存储多个相同数据类型的集合。 2.数组的创建方式123456//数组的创建方式1int[] a = &amp;#123;1,2,3&amp;#125;;//方式2int[] b = new int[]&amp;#123;1,2,3&amp;#125;;//方式3int[] c = new int[3];">
<meta property="og:type" content="article">
<meta property="og:title" content="玩转数据结构">
<meta property="og:url" content="http://yoursite.com/2018/09/14/算法与数据结构/index.html">
<meta property="og:site_name" content="HXK">
<meta property="og:description" content="1.数组1.数组的定义数组是一种常见的数据类型，用于存储多个相同数据类型的集合。 2.数组的创建方式123456//数组的创建方式1int[] a = &amp;#123;1,2,3&amp;#125;;//方式2int[] b = new int[]&amp;#123;1,2,3&amp;#125;;//方式3int[] c = new int[3];">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2018/09/14/算法与数据结构/typora/lmage/1534908873512.png">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/UtWdDgynLdZWD664KnCQ2x68C8NUSn9ict227KGW16ZelicMClaul5S6BZuYpzG0yuJU3tibvlcSkd4VhMrWvotTg/640?tp=webp&wxfrom=5&wx_lazy=1">
<meta property="og:image" content="https://blog.csdn.net/qq_37606901/article/details/79484711">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdZWD664KnCQ2x68C8NUSn9ic37SnM2ZvgIUFk2qIFNpCwYLLx2Zahibgx9OcfFNJeUic15MLzF2TrYWA/640?tp=webp&wxfrom=5&wx_lazy=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/UtWdDgynLdZWD664KnCQ2x68C8NUSn9ickla6KbCCFu39obZuGEooFPtVsap3picXKYLMLh3ibpeZ7b8lia1SvDN4w/640?tp=webp&wxfrom=5&wx_lazy=1">
<meta property="og:image" content="http://yoursite.com/2018/09/14/算法与数据结构/Users/hxk/Desktop/Typora/assets/1536889557305.png">
<meta property="og:image" content="http://yoursite.com/2018/09/14/算法与数据结构/1536890094128.png">
<meta property="og:image" content="http://yoursite.com/2018/09/14/算法与数据结构/1536890115431.png">
<meta property="og:image" content="http://yoursite.com/2018/09/14/算法与数据结构/1536890693570.png">
<meta property="og:updated_time" content="2018-10-07T03:17:25.930Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="玩转数据结构">
<meta name="twitter:description" content="1.数组1.数组的定义数组是一种常见的数据类型，用于存储多个相同数据类型的集合。 2.数组的创建方式123456//数组的创建方式1int[] a = &amp;#123;1,2,3&amp;#125;;//方式2int[] b = new int[]&amp;#123;1,2,3&amp;#125;;//方式3int[] c = new int[3];">
<meta name="twitter:image" content="http://yoursite.com/2018/09/14/算法与数据结构/typora/lmage/1534908873512.png">






  <link rel="canonical" href="http://yoursite.com/2018/09/14/算法与数据结构/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>玩转数据结构 | HXK</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?27cb89b569db5ce43613c8d1a7b8f9c9";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HXK</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/14/算法与数据结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="superman">
      <meta itemprop="description" content="运动只为改变">
      <meta itemprop="image" content="/images/chai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HXK">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">玩转数据结构
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-14 20:18:08" itemprop="dateCreated datePublished" datetime="2018-09-14T20:18:08+08:00">2018-09-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-10-07 11:17:25" itemprop="dateModified" datetime="2018-10-07T11:17:25+08:00">2018-10-07</time>
              
            
          </span>

          

          
            
          

          
          
             <span id="/2018/09/14/算法与数据结构/" class="leancloud_visitors" data-flag-title="玩转数据结构">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon"
            >
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h2><h3 id="1-数组的定义"><a href="#1-数组的定义" class="headerlink" title="1.数组的定义"></a>1.数组的定义</h3><p>数组是一种常见的数据类型，用于存储多个相同数据类型的集合。</p>
<h3 id="2-数组的创建方式"><a href="#2-数组的创建方式" class="headerlink" title="2.数组的创建方式"></a>2.数组的创建方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组的创建方式1</span></span><br><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//方式3</span></span><br><span class="line"><span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="3-向数组中添加，查询搜索和删除元素"><a href="#3-向数组中添加，查询搜索和删除元素" class="headerlink" title="3.向数组中添加，查询搜索和删除元素"></a>3.向数组中添加，查询搜索和删除元素</h3><h3 id="4-动态数组"><a href="#4-动态数组" class="headerlink" title="4.动态数组"></a>4.动态数组</h3><ul>
<li>数组动态伸缩</li>
<li>数组扩容，缩容</li>
</ul>
<h3 id="5-时间复杂度"><a href="#5-时间复杂度" class="headerlink" title="5.时间复杂度"></a>5.时间复杂度</h3><ul>
<li>算法的<strong>时间复杂度</strong>是一个函数，它定性描述了该算法的运行时间 </li>
<li>均摊复杂度</li>
<li>复杂度震荡</li>
</ul>
<h2 id="2-栈和队列"><a href="#2-栈和队列" class="headerlink" title="2.栈和队列"></a>2.栈和队列</h2><h3 id="1-栈"><a href="#1-栈" class="headerlink" title="1.栈"></a>1.栈</h3><ul>
<li>栈（stack）又名堆栈，它是一种线性表 ，<strong>先进后出</strong>，从栈顶添加元素，栈顶取出</li>
</ul>
<p>###2.栈的应用</p>
<ul>
<li>撤销操作，就相当于一个先进后出</li>
<li>程序调用的系统栈</li>
</ul>
<p><img src="/2018/09/14/算法与数据结构/typora\lmage\1534908873512.png" alt="1534908873512"></p>
<ul>
<li>括号匹配，用栈解决问题</li>
</ul>
<h3 id="3-队列"><a href="#3-队列" class="headerlink" title="3.队列"></a>3.队列</h3><ul>
<li>队列也是一种线性结构，先进先出。</li>
<li>数组队列</li>
<li>循环队列<ul>
<li>front表示队首的元素</li>
<li>tail表示队尾下一个元素的位置</li>
</ul>
</li>
</ul>
<h2 id="3-链表"><a href="#3-链表" class="headerlink" title="3.链表"></a>3.链表</h2><ul>
<li>链表是一种最简单的，真正的动态数据结构</li>
<li>优点<ul>
<li>真正的动态，不需要处理固定容量问题</li>
</ul>
</li>
<li>缺点<ul>
<li>丧失了随机访问的能力</li>
</ul>
</li>
<li>节点装载元素，节点连接</li>
<li>链表实现栈，链表头做栈顶</li>
<li>链表实现队列，链表头取元素，链表尾部插入元素</li>
</ul>
<h2 id="4-链表与递归"><a href="#4-链表与递归" class="headerlink" title="4.链表与递归"></a>4.链表与递归</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><ul>
<li>递归通常就是把一个原问题转化为一个规模较小的问题</li>
<li>递归调用是有代价的：函数调用+系统栈空间</li>
</ul>
<h3 id="2-二分搜索树"><a href="#2-二分搜索树" class="headerlink" title="2.二分搜索树"></a>2.二分搜索树</h3><p>二叉树</p>
<p>二分搜索树是特殊的二叉树</p>
<ul>
<li><strong>二叉树前序遍历</strong><ul>
<li>首先访问根节点</li>
<li>然后访问根节点的左子树</li>
<li>然后访问根节点的右子树</li>
</ul>
</li>
<li><strong>中序遍历</strong><ul>
<li>先访问左子树</li>
<li>再访问节点</li>
<li>后访问右子树</li>
<li><strong>中序遍历后是从小到大的排序结果</strong></li>
</ul>
</li>
<li><strong>后序遍历</strong><ul>
<li>先访问左子树</li>
<li>再访问右子树</li>
<li>后访问根节点</li>
</ul>
</li>
<li><strong>非递归遍历</strong>需要借助<strong>栈</strong>Stack</li>
</ul>
<h3 id="3-深度优先遍历（DFS）"><a href="#3-深度优先遍历（DFS）" class="headerlink" title="3.深度优先遍历（DFS）"></a>3.深度优先遍历（DFS）</h3><ul>
<li>前中后序遍历本质都是dfs</li>
</ul>
<h3 id="4-广度优先遍历（BFS）"><a href="#4-广度优先遍历（BFS）" class="headerlink" title="4.广度优先遍历（BFS）"></a>4.广度优先遍历（BFS）</h3><ul>
<li>也叫<strong>层序遍历</strong></li>
</ul>
<h2 id="5-排序基础"><a href="#5-排序基础" class="headerlink" title="5.排序基础"></a>5.排序基础</h2><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h3><ul>
<li><strong>基本原理</strong><ol>
<li>从第一个数据开始，与第二个数据相比较，如果第二个数据小于第一个数据，则交换两个数据的位置</li>
<li>指针由第一个数据移向第二个数据，第二个数据与第三个数据相比较，如果第三个数据小于第二个数据，则交换两个数据的位置</li>
<li>依此类推，完成第一轮排序。第一轮排序结束后，最大的元素被移到了最右面</li>
<li>依照上面的过程进行第二轮排序，将第二大的排在倒数第二的位置</li>
<li>重复上述过程，没排完一轮，比较次数就减少一次</li>
<li>共进行n-1轮排序</li>
</ol>
</li>
<li><strong>编码思路：</strong><ul>
<li>需要两层循环，第一层循环i表示排序的轮数，第二层循环j表示比较的次数</li>
</ul>
</li>
<li><strong>冒泡排序算法总结</strong><ul>
<li>N个元素需要排序N-1轮</li>
<li>第i轮需要比较N-i次</li>
<li>N个元素比较，需要比较n(n-1)/2次</li>
<li><strong>冒泡排序算法复杂度较高O(n*n)</strong></li>
</ul>
</li>
</ul>
<h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h3><ul>
<li>选择排序是对冒泡排序的改进，比较次数和冒泡排序相同，但是交换次数要小于冒泡排序，<strong>时间复杂度为O(n*n)</strong></li>
<li><strong>基本原理</strong>：<ol>
<li>从第一个元素开始，分别与后面的元素向比较，找到最小的元素与第一个元素交换位置</li>
<li>从第二个元素开始，分别与后面的元素相比较，找到剩余元素中最小的元素，与第二个元素交换</li>
<li>重复上述步骤，直到所有的元素都排成由小到大为止</li>
</ol>
</li>
<li><strong>编码思路：</strong><ul>
<li>需要两次循环，第一层循环i表示每轮指针指向的位置，将最小值min初始化为第i个元素，第二层循环从j=i+1开始，分别与min比较，如果小于min，则更新min的值，内层循环结束后；交换min元素和第i个元素的位置。以此类推进行下一轮循环，直到i=length时停止循环。当i=length时，说明小的元素已经全部移到了左面，因此无需进行内层循环了</li>
</ul>
</li>
<li><strong>选择排序总结</strong><ol>
<li>N个元素需要排序N-1轮</li>
<li>第i轮需要比较N-i次</li>
<li>N个元素排序，需要比较n（n-1）/2次</li>
<li>选择排序的算法复杂度仍为O（n*n）</li>
<li>相比于冒泡排序，选择排序的交换次数大大减少，因此速度要快于冒泡排序</li>
</ol>
</li>
</ul>
<h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h3><ul>
<li>插入排序是简单排序中最快的排序算法，虽然时间复杂度仍然为O(n*n)，但是却比冒泡排序和选择排序快很多</li>
<li><strong>基本原理：</strong><ol>
<li>将指针指向某个元素，假设该元素左侧的元素全部有序，将该元素抽取出来，然后按照从右往左的顺序分别与其左边的元素比较，遇到比其大的元素便将元素右移，直到找到比该元素小的元素或者找到最左面发现其左侧的元素都比它大，停止</li>
<li>此时会出现一个空位，将该元素放入到空位中，此时该元素左侧的元素都比它小，右侧的元素都比它大</li>
<li>指针向后移动一位，重复上述过程。每操作一轮，左侧有序元素都增加一个，右侧无序元素都减少一个</li>
</ol>
</li>
<li><strong>编码分析：</strong><ul>
<li>需要两层循环，第一层循环index表示上述例子中的指针，即遍历从坐标为1开始的每一个元素；第二层循环从leftindex=index-1开始，leftindex–向左遍历，将每一个元素与i处的元素比较，直到j处的元素小于i出的元素或者leftindex&lt;0；遍历从i到j的每一个元素使其右移，最后将index处的元素放到leftindex处的空位处</li>
</ul>
</li>
<li><strong>插入排序总结：</strong><ul>
<li>插入排序的速度约比冒泡排序快一倍（比较次数少一倍），比选择排序还要快一些，对于基本有序的数据，插入排序的速度会很快，是简单排序中效率最高的排序算法</li>
</ul>
</li>
</ul>
<h3 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4.希尔排序"></a>4.希尔排序</h3><ul>
<li>希尔排序属于插入类排序,是将整个有序序列分割成若干小的子序列分别进行插入排序</li>
<li><strong>基本原理：</strong><ul>
<li>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（<strong>此时插入排序较快</strong>）</li>
<li><strong>步长的选择是希尔排序的重要部分</strong>。只要最终步长为1任何步长序列都可以工作（<strong>且步长要小于数组长度</strong>）。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序</li>
</ul>
</li>
</ul>
<h3 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5.归并排序"></a>5.归并排序</h3><ul>
<li>O(nlogN)</li>
<li>归并排序 (merge sort) 是一类与插入排序、交换排序、选择排序不同的另一种排序方法。归并的含义是将两个或两个以上的有序表合并成一个新的有序表,</li>
<li><strong>将两个或者两个以上的有序表合并成一个新的有序表，即把待排序的序列分成若干个子序列,每个序列是有序的，然后把有序序列合并成整体有序序列</strong></li>
<li>是一种<strong>稳定排序方式</strong></li>
</ul>
<h3 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6.快速排序"></a>6.快速排序</h3><ul>
<li><strong>算法思路：</strong><ol>
<li>设置两个变量i、j，<a href="https://baike.baidu.com/item/%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">排序</a>开始的时候：i=0，j=N-1</li>
<li>以第一个数组元素作为关键数据，赋值给<strong>key</strong>，即<strong>key</strong>=A[0]</li>
<li>从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于<strong>key</strong>的值A[j]，将A[j]和A[i]互换</li>
<li>从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于<strong>key</strong>的A[i]，将A[i]和A[j]互换</li>
<li>重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于<strong>key</strong>,4中A[i]不大于<strong>key</strong>的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）</li>
</ol>
</li>
</ul>
<h3 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7.堆排序"></a>7.堆排序</h3><ul>
<li>了解堆<ul>
<li>二叉堆是一颗完全二叉树（最大堆）</li>
<li>堆中的某节点的值总是小于其父节点的值（大顶堆）</li>
</ul>
</li>
</ul>
<p>##8.树，森林，二叉树的转换</p>
<ul>
<li><p>将树或者森林转换成对应的二叉树方法：</p>
<ol>
<li>在所有的兄的节点之间添加一条连线，如果是森林，则在其所有树的树根之间同样添加一条连线。</li>
<li>对于树，森林的每个节点，除保留其到第一个子女的连线外，撤销其到其他子女的连线</li>
<li>将以上得到的树按顺时针旋转45°</li>
<li>得到对应的二叉树</li>
</ol>
</li>
<li><p>二叉树到森林的转换</p>
<p>上述过程的逆过程</p>
<p>3-&gt;2-&gt;1.</p>
</li>
</ul>
<h2 id="9-线性表的检索（查找）"><a href="#9-线性表的检索（查找）" class="headerlink" title="9.线性表的检索（查找）"></a>9.线性表的检索（查找）</h2><h3 id="1-顺序检索"><a href="#1-顺序检索" class="headerlink" title="1.顺序检索"></a>1.顺序检索</h3><ul>
<li>从线性表的头扫描到尾部</li>
</ul>
<h3 id="2-二分法检索（折半查找nlog2n）"><a href="#2-二分法检索（折半查找nlog2n）" class="headerlink" title="2.二分法检索（折半查找nlog2n）"></a>2.二分法检索（折半查找nlog2n）</h3><ul>
<li>条件：<strong>只适用于顺序存储结构</strong></li>
<li>找到中间节点，判断大于还是小于，取前半段还是后半段，再取半段中的中间节点，判断，重复进行，直到找到为止。</li>
</ul>
<h3 id="3-分块检索"><a href="#3-分块检索" class="headerlink" title="3.分块检索"></a>3.分块检索</h3><ul>
<li>结合顺序查找和二分查找</li>
<li>基本思想：<ul>
<li>将线性表分为若干块，在每一块中，结点的存放不一定有序，但块与块之间必须是分块有序的</li>
</ul>
</li>
</ul>
<h3 id="4-二叉排序树"><a href="#4-二叉排序树" class="headerlink" title="4.二叉排序树"></a>4.二叉排序树</h3><h3 id="5-丰满树和平衡二叉排序树（AVL树"><a href="#5-丰满树和平衡二叉排序树（AVL树" class="headerlink" title="5.丰满树和平衡二叉排序树（AVL树)"></a>5.丰满树和平衡二叉排序树（AVL树)</h3><ul>
<li><p>丰满树：</p>
<ul>
<li>满足任意两个非孩子节点的高度之差的绝对值小于等于1</li>
</ul>
</li>
<li><p>平衡二叉树具有的性质：</p>
<ol>
<li>它的左子树和右子树都是平衡二叉树，且左子树和右子树高度之差的绝对值不超过1（可以是空树）</li>
<li><strong>平衡因子</strong>即平衡二叉树的左右子树高度差，可取-1，0，1</li>
<li>左子树深度减去右子树的为平衡因子</li>
</ol>
</li>
<li><p>平衡二叉树的高度节点数量之间的关系也是O(logn)</p>
</li>
</ul>
<h3 id="6-AVL树的插入算法描述"><a href="#6-AVL树的插入算法描述" class="headerlink" title="6.AVL树的插入算法描述"></a>6.AVL树的插入算法描述</h3><ul>
<li>目的：维护平衡<ol>
<li>若AVL树t为空树，则插入一个数据元素为x的新节点作为t的根结点，树的深度为1.</li>
<li>若x和AVL树的根节点关键字相同，则不插入。</li>
<li>若x的关键字小于AVL树得根结点，分以下三种情况处理：<ul>
<li>若AVL树的根结点的平衡因子为-1，则将根结点的平衡因子调节为0，树的深度不表。</li>
<li>若AVL树的根节点的平衡因子为0，则将根结点的平衡因子调节为1，树的深度加一</li>
<li>若AVL树的平衡因子为1，则当改左子树根结点为1时，需要进行LL平衡旋转，当该树的左子树的根结点平衡因子为-1时需要LR平衡旋转。</li>
</ul>
</li>
<li>若x关键字大于根节点，则将x插入到该树的右子树，并且当插入后的右子树深度增加1时，参考（3）按情况处理.</li>
</ol>
</li>
</ul>
<h3 id="7-B-树和B-树"><a href="#7-B-树和B-树" class="headerlink" title="7.B-树和B+树"></a>7.B-树和B+树</h3><ul>
<li><strong>B-树：</strong>一种适合于外查找的树</li>
<li>一颗m阶B树是一棵m路平衡搜索树，或者是空树，满足以下性质。<ol>
<li>根结点至少有两个子女</li>
<li>每个非根节点所包含的关键字个数 n 满足：[m/2]-1&lt;=n&lt;=m-1</li>
<li>除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故<strong>内部子树</strong>个数 k 满足：[m/2]&lt;= k &lt;= m </li>
<li>所有的叶子结点都位于同一层</li>
</ol>
</li>
<li><strong>B+树：</strong>m阶B+树结构定义<ol>
<li>树中每个结点至多有m棵子树</li>
<li>除根结点之外的每个结点至少有[m/2]棵子树</li>
<li>若根结点不是叶子节点且非空，则至少有2棵子树</li>
<li>所有的叶子结点包含全部关键字及指向相应记录的指针，而且叶子结点按关键字大小顺序链接（可以把每个叶子节点看成一个基本索引块，它的指针不在指向另一级索引，而是直接指向数据文件中的记录）</li>
</ol>
</li>
<li><strong>B树和B+树区别：</strong><ul>
<li>为什么是B+树而不是B树呢，因为它内节点不存储data，这样一个节点就可以存储更多的key</li>
<li>B+树上增加了顺序访问指针，也就是每个叶子节点增加一个指向相邻叶子节点的指针，这样一棵树成了数据库系统实现索引的首选数据结构</li>
</ul>
</li>
</ul>
<h2 id="10-树的总结"><a href="#10-树的总结" class="headerlink" title="10.树的总结"></a>10.树的总结</h2><h3 id="一、二叉查找树"><a href="#一、二叉查找树" class="headerlink" title="一、二叉查找树"></a>一、二叉查找树</h3><p>（1）二叉树简介：</p>
<p>二叉查找树也称为有序二叉查找树，满足二叉查找树的一般性质，是指一棵空树具有如下性质：</p>
<p>1、任意节点左子树不为空,则左子树的值均小于根节点的值；</p>
<p>2、任意节点右子树不为空,则右子树的值均大于于根节点的值；</p>
<p>3、任意节点的左右子树也分别是二叉查找树；</p>
<p>4、没有键值相等的节点；<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/UtWdDgynLdZWD664KnCQ2x68C8NUSn9ict227KGW16ZelicMClaul5S6BZuYpzG0yuJU3tibvlcSkd4VhMrWvotTg/640?tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="img"><br>上图为一个普通的二叉查找树，按照中序遍历的方式可以从小到大的顺序排序输出：2、3、5、6、7、8。</p>
<p>对上述二叉树进行查找，如查键值为5的记录，先找到根，其键值是6，6大于5，因此查找6的左子树，找到3；而5大于3，再找其右子树；一共找了3次。如果按2、3、5、6、7、8的顺序来找同样需求3次。用同样的方法在查找键值为8的这个记录，这次用了3次查找，而顺序查找需要6次。计算平均查找次数得：顺序查找的平均查找次数为（1+2+3+4+5+6）/ 6 = 3.3次，二叉查找树的平均查找次数为（3+3+3+2+2+1）/6=2.3次。二叉查找树的平均查找速度比顺序查找来得更快。</p>
<p>（2）局限性及应用</p>
<p>一个二叉查找树是由n个节点随机构成，所以，对于某些情况，二叉查找树会退化成一个有n个节点的线性链。如下图：<br><img src="https://blog.csdn.net/qq_37606901/article/details/79484711" alt="img"><br>大家看上图，如果我们的根节点选择是最小或者最大的数，那么二叉查找树就完全退化成了线性结构。上图中的平均查找次数为（1+2+3+4+5+5）/6=3.16次，和顺序查找差不多。显然这个二叉树的查询效率就很低，因此若想最大性能的构造一个二叉查找树，需要这个二叉树是平衡的（这里的平衡从一个显著的特点可以看出这一棵树的高度比上一个输的高度要大，在相同节点的情况下也就是不平衡），从而引出了一个新的定义-平衡二叉树AVL。</p>
<p>###二、AVL树</p>
<p>（1）简介</p>
<p>AVL树是带有平衡条件的二叉查找树，一般是用平衡因子差值判断是否平衡并通过旋转来实现平衡，左右子树树高不超过1，和红黑树相比，它是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差不超过1）。不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而旋转是非常耗时的，由此我们可以知道AVL树适合用于插入删除次数比较少，但查找多的情况。<br>从上面是一个普通的平衡二叉树，这张图我们可以看出，任意节点的左右子树的平衡因子差值都不会大于1。</p>
<p>（2）局限性</p>
<p>由于维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果应用场景中对插入删除不频繁，只是对查找要求较高，那么AVL还是较优于红黑树。</p>
<p>（3）应用</p>
<p>1、Windows NT内核中广泛存在；</p>
<p>###三、红黑树</p>
<p>（1）简介</p>
<p><strong>一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是red或black</strong>。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍。它是一种弱平衡二叉树(由于是若平衡，可以推出，相同的节点情况下，AVL树的高度低于红黑树)，相对于要求严格的AVL树来说，它的旋转次数变少，所以对于搜索、插入、删除操作多的情况下，我们就用红黑树。</p>
<p>（2）性质</p>
<p>1、每个节点非红即黑；<br>2、根节点是黑的；<br>3、每个叶节点(叶节点即树尾端NULL指针或NULL节点)都是黑的；<br>4、如果一个节点是红的,那么它的两儿子都是黑的；<br>5、对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点；<br>6、每条路径都包含相同的黑节点；</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdZWD664KnCQ2x68C8NUSn9ic37SnM2ZvgIUFk2qIFNpCwYLLx2Zahibgx9OcfFNJeUic15MLzF2TrYWA/640?tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="img"></p>
<p>（3）应用</p>
<p>1、广泛用于C++的STL中，Map和Set都是用红黑树实现的；<br>2、著名的Linux进程调度Completely Fair Scheduler，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一颗红黑树上，每个虚拟地址区域都对应红黑树的一个节点，左指针指向相邻的地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间；<br>3、IO多路复用epoll的实现采用红黑树组织管理sockfd，以支持快速的增删改查；<br>4、Nginx中用红黑树管理timer，因为红黑树是有序的，可以很快的得到距离当前最小的定时器；<br>5、Java中TreeMap的实现；</p>
<p>###四、B/B+树</p>
<p>说了上述的三种树：二叉查找树、AVL和红黑树，似乎我们还没有摸到MySQL为什么要使用B+树作为索引的实现，不要急，接下来我们就先探讨一下什么是B树。</p>
<p>（1）简介</p>
<p>我们在MySQL中的数据一般是放在磁盘中的，读取数据的时候肯定会有访问磁盘的操作，磁盘中有两个机械运动的部分，分别是盘片旋转和磁臂移动。盘片旋转就是我们市面上所提到的多少转每分钟，而磁盘移动则是在盘片旋转到指定位置以后，移动磁臂后开始进行数据的读写。那么这就存在一个定位到磁盘中的块的过程，而定位是磁盘的存取中花费时间比较大的一块，毕竟机械运动花费的时候要远远大于电子运动的时间。当大规模数据存储到磁盘中的时候，显然定位是一个非常花费时间的过程，但是我们可以通过B树进行优化，提高磁盘读取时定位的效率。</p>
<p>为什么B类树可以进行优化呢？我们可以根据B类树的特点，构造一个多阶的B类树，然后在尽量多的在结点上存储相关的信息，保证层数尽量的少，以便后面我们可以更快的找到信息，磁盘的I/O操作也少一些，而且B类树是平衡树，每个结点到叶子结点的高度都是相同，这也保证了每个查询是稳定的。</p>
<p>总的来说，<strong>B/B+树是为了磁盘或其它存储设备而设计的一种平衡多路查找树(相对于二叉</strong>，B树每个内节点有多个分支)，与红黑树相比，在相同的的节点的情况下，一颗B/B+树的高度远远小于红黑树的高度(在下面B/B+树的性能分析中会提到)。B/B+树上操作的时间通常由存取磁盘的时间和CPU计算时间这两部分构成，而CPU的速度非常快，所以B树的操作效率取决于访问磁盘的次数，关键字总数相同的情况下B树的高度越小，磁盘I/O所花的时间越少。</p>
<p>注意B-树就是B树，-只是一个符号。</p>
<p>（2）B树的性质</p>
<p>1、定义任意非叶子结点最多只有M个儿子，且M&gt;2；<br>2、根结点的儿子数为[2, M]；<br>3、除根结点以外的非叶子结点的儿子数为[M/2, M]；<br>4、每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）<br>5、非叶子结点的关键字个数=指向儿子的指针个数-1；<br>6、非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；<br>7、非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；<br>8、所有叶子结点位于同一层；<br>这里只是一个简单的B树，在实际中B树节点中关键字很多的，上面的图中比如35节点，35代表一个key(索引)，而小黑块代表的是这个key所指向的内容在内存中实际的存储位置，是一个指针。</p>
<p>###五、B+树</p>
<p>（1）简介</p>
<p>B+树是应文件系统所需而产生的一种B树的变形树（文件的目录一级一级索引，只有最底层的叶子节点（文件）保存数据）非叶子节点只保存索引，不保存实际的数据，数据都保存在叶子节点中，这不就是文件系统文件的查找吗?</p>
<p>我们就举个文件查找的例子：有3个文件夹a、b、c， a包含b，b包含c，一个文件yang.c，a、b、c就是索引（存储在非叶子节点）， a、b、c只是要找到的yang.c的key，而实际的数据yang.c存储在叶子节点上。</p>
<p>所有的非叶子节点都可以看成索引部分！</p>
<p>（2）B+树的性质(下面提到的都是和B树不相同的性质)</p>
<p>1、非叶子节点的子树指针与关键字个数相同；<br>2、非叶子节点的子树指针p[i],指向关键字值属于[k[i],k[i+1]]的子树.(B树是开区间,也就是说B树不允许关键字重复,B+树允许重复)；<br>3、为所有叶子节点增加一个链指针；<br>4、所有关键字都在叶子节点出现(稠密索引). (且链表中的关键字恰好是有序的)；<br>5、非叶子节点相当于是叶子节点的索引(稀疏索引),叶子节点相当于是存储(关键字)数据的数据层；<br>6、更适合于文件系统；</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/UtWdDgynLdZWD664KnCQ2x68C8NUSn9ickla6KbCCFu39obZuGEooFPtVsap3picXKYLMLh3ibpeZ7b8lia1SvDN4w/640?tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="img"></p>
<p>非叶子节点（比如5，28，65）只是一个key（索引），实际的数据存在叶子节点上（5，8，9）才是真正的数据或指向真实数据的指针。</p>
<p>（3）应用　　</p>
<p>1、B和B+树主要用在文件系统以及数据库做索引，比如MySQL；</p>
<p>###六、B/B+树性能分析</p>
<p>n个节点的平衡二叉树的高度为H(即logn)，而n个节点的B/B+树的高度为logt((n+1)/2)+1；<br>若要作为内存中的查找表，B树却不一定比平衡二叉树好，尤其当m较大时更是如此。因为查找操作CPU的时间在B-树上是O(mlogtn)=O(lgn(m/lgt))，而m/lgt&gt;1；所以m较大时O(mlogtn)比平衡二叉树的操作时间大得多。因此在内存中使用B树必须取较小的m。（通常取最小值m=3，此时B-树中每个内部结点可以有2或3个孩子，这种3阶的B-树称为2-3树）。</p>
<p>###七、为什么说B+树比B树更适合数据库索引？</p>
<p>1、 B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。</p>
<p>2、B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
<p>3、由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。</p>
<p>PS：我在知乎上看到有人是这样说的,我感觉说的也挺有道理的：</p>
<p>他们认为数据库索引采用B+树的主要原因是：B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。</p>
<p> 今天看了几篇文章，自己总结一下。</p>
<p>数据库使用B+树肯定是为了提升查找效率。</p>
<p>但是具体如何提升查找效率呢？</p>
<p>查找数据，最简单的方式是顺序查找。但是对于几十万上百万，甚至上亿的数据库查询就很慢了。</p>
<p>所以要对查找的方式进行优化，熟悉的二分查找，二叉树可以把速度提升到O(log(n,2))，查询的瓶颈在于树的深度，最坏的情况要查找到二叉树的最深层，由于，每查找深一层，就要访问更深一层的索引文件。在多达数G的索引文件中，这将是很大的开销。所以，尽量把数据结构设计的更为‘矮胖’一点就可以减少访问的层数。在众多的解决方案中，B-/B+树很好的适合。B-树定义具体可以查阅，简而言之就是中间节点可以多余两个子节点，而且中间的元素可以是一个域。相比B-树，B+树的父节点也必须存在于子节点中，是其中最大或者最小元素，B+树的节点只存储索引key值，具体信息的地址存在于叶子节点的地址中。这就使以页为单位的索引中可以存放更多的节点。减少更多的I/O支出。因此，B+树成为了数据库比较优秀的数据结构，MySQL中MyIsAM和InnoDB都是采用的B+树结构。不同的是前者是非聚集索引，后者主键是聚集索引，所谓聚集索引是物理地址连续存放的索引，在取区间的时候，查找速度非常快，但同样的，插入的速度也会受到影响而降低。聚集索引的物理位置使用链表来进行存储。</p>
<h2 id="11-图"><a href="#11-图" class="headerlink" title="11.图"></a>11.图</h2><h3 id="1-图的基本概念"><a href="#1-图的基本概念" class="headerlink" title="1.图的基本概念"></a>1.图的基本概念</h3><ol>
<li>顶点</li>
<li>无向边，无向图</li>
<li>有向边，有向图</li>
<li>权值</li>
<li>网：带权值的图</li>
<li>子图</li>
<li>度，出度，入度</li>
<li>连通图：图中任意两个顶点都是连通的。</li>
</ol>
<h3 id="2-图的存储结构"><a href="#2-图的存储结构" class="headerlink" title="2.图的存储结构"></a>2.图的存储结构</h3><ul>
<li><strong>邻接矩阵</strong>：用两个数组，一个数组保存顶点集，一个数组保存边集。</li>
<li><img src="/2018/09/14/算法与数据结构/Users\hxk\Desktop\Typora\assets\1536889557305.png" alt="1536889557305"></li>
</ul>
<h3 id="3-图的遍历"><a href="#3-图的遍历" class="headerlink" title="3.图的遍历"></a>3.图的遍历</h3><ol>
<li>深度优先遍历（DFS）：从图中某个顶点v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到。</li>
<li>广度优先遍历（BFS）：假设从C0出发，接着访问C0的邻接点C1和C2，依次访问与C1邻接的未曾访问的C3和C4，然后访问与C2邻接未曾访问的C5，直到全部访问。</li>
</ol>
<h3 id="4-最小生成树"><a href="#4-最小生成树" class="headerlink" title="4.最小生成树"></a>4.最小生成树</h3><ol>
<li>基本概念</li>
<li>普里姆算法（prim）</li>
</ol>
<p><img src="/2018/09/14/算法与数据结构/1536890094128.png"></p>
<ol>
<li>克鲁斯卡尔算法（kruskal）</li>
</ol>
<p><img src="/2018/09/14/算法与数据结构/1536890115431.png"></p>
<h3 id="5-最短路径"><a href="#5-最短路径" class="headerlink" title="5.最短路径"></a>5.最短路径</h3><ol>
<li><p><strong>（Dijkstra）</strong>：把图中的顶点集合V分成两组，第一组为已求出最短路径的顶点集合S（初始时S中只有源节点，以后每求得一条最短路径，就将它对应的顶点加入到集合S中，直到全部顶点都加入到S中）；第二组是未确定最短路径的顶点集合U。</p>
</li>
<li><p>算法步骤：</p>
<pre><code> （1）初始化时，S只含有源节点；
（2）从U中选取一个距离v最小的顶点k加入S中（该选定的距离就是v到k的最短路径长度）；
（3）以k为新考虑的中间点，修改U中各顶点的距离；若从源节点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值是顶点k的距离加上k到u的距离；
（4）重复步骤（2）和（3），直到终点在S中
</code></pre></li>
</ol>
<p><img src="/2018/09/14/算法与数据结构/1536890693570.png"></p>

      
    </div>

    

    
    
    
		 <div>

<div>

    <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>

</div>

</div>

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>superman</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://yoursite.com/2018/09/14/算法与数据结构/" title="玩转数据结构">http://yoursite.com/2018/09/14/算法与数据结构/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li>
</ul>

      </div>
    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/09/14/Spring/" rel="next" title="spring">
                <i class="fa fa-chevron-left"></i> spring
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/09/14/Springmvc/" rel="prev" title="SpringMvc">
                SpringMvc <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/chai.jpg"
                alt="superman" />
            
              <p class="site-author-name" itemprop="name">superman</p>
              <p class="site-description motion-element" itemprop="description">运动只为改变</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-数组"><span class="nav-number">1.</span> <span class="nav-text">1.数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-数组的定义"><span class="nav-number">1.1.</span> <span class="nav-text">1.数组的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-数组的创建方式"><span class="nav-number">1.2.</span> <span class="nav-text">2.数组的创建方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-向数组中添加，查询搜索和删除元素"><span class="nav-number">1.3.</span> <span class="nav-text">3.向数组中添加，查询搜索和删除元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-动态数组"><span class="nav-number">1.4.</span> <span class="nav-text">4.动态数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-时间复杂度"><span class="nav-number">1.5.</span> <span class="nav-text">5.时间复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-栈和队列"><span class="nav-number">2.</span> <span class="nav-text">2.栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-栈"><span class="nav-number">2.1.</span> <span class="nav-text">1.栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-队列"><span class="nav-number">2.2.</span> <span class="nav-text">3.队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-链表"><span class="nav-number">3.</span> <span class="nav-text">3.链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-链表与递归"><span class="nav-number">4.</span> <span class="nav-text">4.链表与递归</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-递归"><span class="nav-number">4.1.</span> <span class="nav-text">1.递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-二分搜索树"><span class="nav-number">4.2.</span> <span class="nav-text">2.二分搜索树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-深度优先遍历（DFS）"><span class="nav-number">4.3.</span> <span class="nav-text">3.深度优先遍历（DFS）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-广度优先遍历（BFS）"><span class="nav-number">4.4.</span> <span class="nav-text">4.广度优先遍历（BFS）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-排序基础"><span class="nav-number">5.</span> <span class="nav-text">5.排序基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-冒泡排序"><span class="nav-number">5.1.</span> <span class="nav-text">1.冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-选择排序"><span class="nav-number">5.2.</span> <span class="nav-text">2.选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-插入排序"><span class="nav-number">5.3.</span> <span class="nav-text">3.插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-希尔排序"><span class="nav-number">5.4.</span> <span class="nav-text">4.希尔排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-归并排序"><span class="nav-number">5.5.</span> <span class="nav-text">5.归并排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-快速排序"><span class="nav-number">5.6.</span> <span class="nav-text">6.快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-堆排序"><span class="nav-number">5.7.</span> <span class="nav-text">7.堆排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-线性表的检索（查找）"><span class="nav-number">6.</span> <span class="nav-text">9.线性表的检索（查找）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-顺序检索"><span class="nav-number">6.1.</span> <span class="nav-text">1.顺序检索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-二分法检索（折半查找nlog2n）"><span class="nav-number">6.2.</span> <span class="nav-text">2.二分法检索（折半查找nlog2n）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-分块检索"><span class="nav-number">6.3.</span> <span class="nav-text">3.分块检索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-二叉排序树"><span class="nav-number">6.4.</span> <span class="nav-text">4.二叉排序树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-丰满树和平衡二叉排序树（AVL树"><span class="nav-number">6.5.</span> <span class="nav-text">5.丰满树和平衡二叉排序树（AVL树)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-AVL树的插入算法描述"><span class="nav-number">6.6.</span> <span class="nav-text">6.AVL树的插入算法描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-B-树和B-树"><span class="nav-number">6.7.</span> <span class="nav-text">7.B-树和B+树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-树的总结"><span class="nav-number">7.</span> <span class="nav-text">10.树的总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、二叉查找树"><span class="nav-number">7.1.</span> <span class="nav-text">一、二叉查找树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-图"><span class="nav-number">8.</span> <span class="nav-text">11.图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-图的基本概念"><span class="nav-number">8.1.</span> <span class="nav-text">1.图的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-图的存储结构"><span class="nav-number">8.2.</span> <span class="nav-text">2.图的存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-图的遍历"><span class="nav-number">8.3.</span> <span class="nav-text">3.图的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-最小生成树"><span class="nav-number">8.4.</span> <span class="nav-text">4.最小生成树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-最短路径"><span class="nav-number">8.5.</span> <span class="nav-text">5.最短路径</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">superman</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Pisces</a> v6.4.1</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  





  
  









  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.1"></script>



  



  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script>
    
    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function ({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', `/classes/Counter/${counter.objectId}`, JSON.stringify({ time: { "__op":"Increment", "amount":1 } }))
            
            .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(counter.time + 1);
            })
            
            .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
            })
          } else {
            
              Counter('post', '/classes/Counter', JSON.stringify({ title: title, url: url, time: 1}))
                .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(1);
                })
                .fail(function () {
                  console.log('Failed to create');
                });
            
          }
        })
      .fail(function ({ responseJSON }) {
        console.log('LeanCloud Counter Error:' + responseJSON.code + " " + responseJSON.error);
      });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + "7HLliIdzmoQbjE3d7zsrpvM8-gzGzoHsz")
        .done(function ({ api_server }) {
          var Counter = function (method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': "7HLliIdzmoQbjE3d7zsrpvM8-gzGzoHsz",
                'X-LC-Key': "fGmrlfK2mPp7SsPplBu5j3G6",
                'Content-Type': 'application/json',
              },
              data: data,
            });
          };
          
          addCount(Counter);
          
        })
    });
  </script>



  

  

  

  
  

  

  

  

  

  

</body>
</html>
